<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Prime Mind</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html, body {
        overscroll-behavior: none;
        overflow: hidden;
      }
    </style>
</head>
<body class="bg-gray-900">
    <div id="root"></div>
    <script type="text/babel">
/*
MIT License

Copyright (c) 2024 Prime Breath Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify,merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, a to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// --- SCRIPT START ---

// Base React hooks
const { useState, useEffect, useCallback, useRef, useMemo } = React;

// Inlined from services/primeService.ts
let primeSieve = [];
let sieveLimit = -1;
const getPrimeSieve = (limit) => {
  if (limit <= sieveLimit) {
    return primeSieve;
  }
  
  sieveLimit = limit;
  const sieve = new Array(limit + 1).fill(true);
  sieve[0] = sieve[1] = false;
  for (let i = 2; i * i <= limit; i++) {
    if (sieve[i]) {
      for (let j = i * i; j <= limit; j += i) {
        sieve[j] = false;
      }
    }
  }
  primeSieve = sieve;
  return primeSieve;
};

// --- START TONE SERVICE ---
class ToneService {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.2; // Lowered for sustained polyphony
        this.reverbNode = this.audioContext.createConvolver();
        this.createReverb();
        this.masterGain.connect(this.reverbNode);
        this.reverbNode.connect(this.audioContext.destination);
        
        this.activeTones = new Map();
        this.toneQueue = [];
        this.maxPolyphony = 5;
    }

    createReverb() {
        if (!this.audioContext) return;
        const sampleRate = this.audioContext.sampleRate;
        const duration = 2.5;
        const decay = 2.0;
        const length = sampleRate * duration;
        const impulse = this.audioContext.createBuffer(2, length, sampleRate);
        const impulseL = impulse.getChannelData(0);
        const impulseR = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {
            impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        this.reverbNode.buffer = impulse;
    }
    
    primeToFrequency(prime) {
        const scale = [0, 2, 4, 7, 9]; // Major pentatonic intervals
        const baseNote = 24; // C2 MIDI
        const octaveRange = 4;
        const notesInScale = scale.length;
        const totalNotes = octaveRange * notesInScale;
        const noteIndex = prime % totalNotes;
        const octave = Math.floor(noteIndex / notesInScale);
        const scaleDegree = noteIndex % notesInScale;
        const midiNote = baseNote + (octave * 12) + scale[scaleDegree];
        return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    play(prime) {
        if (!this.audioContext || !prime || prime <= 0) return;
        if (this.audioContext.state === 'suspended') this.audioContext.resume();
        if (this.activeTones.has(prime)) return;

        if (this.toneQueue.length >= this.maxPolyphony) {
            const oldestPrime = this.toneQueue.shift();
            if (oldestPrime) this.stop(oldestPrime);
        }

        const now = this.audioContext.currentTime;
        const freq = this.primeToFrequency(prime);

        const osc1 = this.audioContext.createOscillator();
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(freq, now);

        const osc2 = this.audioContext.createOscillator();
        osc2.type = 'sine';
        const detuneAmount = 1.005; // a subtle detune for a chorus effect
        osc2.frequency.setValueAtTime(freq * detuneAmount, now);
        
        const gainNode1 = this.audioContext.createGain();
        gainNode1.gain.setValueAtTime(0, now);
        gainNode1.gain.linearRampToValueAtTime(0.3, now + 0.8); // Slower attack, slightly lower peak

        const gainNode2 = this.audioContext.createGain();
        gainNode2.gain.setValueAtTime(0, now);
        gainNode2.gain.linearRampToValueAtTime(0.2, now + 0.8); // Second osc is quieter

        osc1.connect(gainNode1);
        osc2.connect(gainNode2);
        gainNode1.connect(this.masterGain);
        gainNode2.connect(this.masterGain);
        
        osc1.start(now);
        osc2.start(now);
        this.activeTones.set(prime, { osc1, osc2, gainNode1, gainNode2 });
        this.toneQueue.push(prime);
    }

    stop(prime) {
        if (this.activeTones.has(prime)) {
            const { osc1, osc2, gainNode1, gainNode2 } = this.activeTones.get(prime);
            const now = this.audioContext.currentTime;
            
            const freq = this.primeToFrequency(prime);

            // Frequencies for C1 to A4, our note range
            const minLogFreq = Math.log(32.7); 
            const maxLogFreq = Math.log(440);
            
            // Fade duration range in seconds
            const minDuration = 0.75;
            const maxDuration = 3.0;

            const logFreq = Math.log(freq);
            let normalizedLogFreq = (logFreq - minLogFreq) / (maxLogFreq - minLogFreq);
            normalizedLogFreq = Math.max(0, Math.min(1, normalizedLogFreq)); // Clamp for safety

            // Inverse linear interpolation: higher freq -> shorter duration
            const fadeOutDuration = maxDuration - normalizedLogFreq * (maxDuration - minDuration);
            
            gainNode1.gain.cancelScheduledValues(now);
            gainNode1.gain.setValueAtTime(gainNode1.gain.value, now);
            gainNode1.gain.linearRampToValueAtTime(0.0001, now + fadeOutDuration);

            gainNode2.gain.cancelScheduledValues(now);
            gainNode2.gain.setValueAtTime(gainNode2.gain.value, now);
            gainNode2.gain.linearRampToValueAtTime(0.0001, now + fadeOutDuration);

            osc1.stop(now + fadeOutDuration + 0.1);
            osc2.stop(now + fadeOutDuration + 0.1);
            this.activeTones.delete(prime);
        }
    }

    clearAllTones() {
        const primesToStop = Array.from(this.activeTones.keys());
        primesToStop.forEach(prime => this.stop(prime));
        this.toneQueue = [];
    }

    cleanup() {
        if (this.audioContext) {
            this.clearAllTones();
            setTimeout(() => {
                if (this.audioContext) {
                   this.audioContext.close().catch(console.error);
                   this.audioContext = null;
                }
            }, 3200); // Increased to accommodate longest fade-out
        }
    }
}
// --- END TONE SERVICE ---


// --- START SHARED UTILS ---
const FADE_DURATION_IN_OUT = 1500;
const calculateFadeOpacity = (timeInPhase, phaseDuration) => {
    if (phaseDuration <= FADE_DURATION_IN_OUT * 2) {
        const half = phaseDuration / 2;
        if (timeInPhase < half) return Math.max(0, timeInPhase / half);
        return Math.max(0, (phaseDuration - timeInPhase) / half);
    }
    if (timeInPhase < FADE_DURATION_IN_OUT) return timeInPhase / FADE_DURATION_IN_OUT;
    if (timeInPhase > phaseDuration - FADE_DURATION_IN_OUT) return (phaseDuration - timeInPhase) / FADE_DURATION_IN_OUT;
    return 1.0;
};

// --- START WAVE OVERLAY SHADER UTILS ---
const waveOverlayState = {
  cycleStartTimestamp: 0,
  colorOffset: 0,
  animatedCount: 100,
  justInhaled: false,
  lastAnimationStyle: null,
};

const waveDataCache = {};
const calculateWaveData = (maxCount) => {
    const cacheKey = maxCount;
    if (waveDataCache[cacheKey]) {
        return waveDataCache[cacheKey];
    }
    const primeSieve = getPrimeSieve(maxCount);
    const primeList = [];
    for (let i = 2; i <= maxCount; i++) {
        if (primeSieve[i]) primeList.push(i);
    }
    const calculatedRings = new Map();
    const thetaSamples = 500;
    const R_base = 50;
    const radial_growth_per_prime = 3;
    const amplitude0 = 5;
    const theta = Array.from({ length: thetaSamples }, (_, i) => (i / (thetaSamples - 1)) * 2 * Math.PI);
    primeList.forEach((p, i) => {
        const points = [];
        const R_i = R_base + radial_growth_per_prime * i;
        for (let j = 0; j < thetaSamples; j++) {
            const angle = theta[j];
            const r = R_i + amplitude0 * Math.sin(p * angle);
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push({ x, y });
        }
        calculatedRings.set(p, points);
    });
    const result = { rings: calculatedRings, primes: primeList };
    waveDataCache[cacheKey] = result;
    return result;
};
// --- END WAVE OVERLAY SHADER UTILS ---

const applyShader = (ctx, shader, timestamp, options = {}) => {
    if (shader === 'None') return;

    const canvas = ctx.canvas;
    const { width, height } = canvas;
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = width;
    tempCanvas.height = height;

    // --- Shader Logic ---
    switch (shader) {
        case 'Bloom':
            tempCtx.filter = 'blur(8px) brightness(1.5)';
            tempCtx.drawImage(canvas, 0, 0);
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.5;
            ctx.drawImage(tempCanvas, 0, 0);
            break;
        case 'Neon':
            tempCtx.filter = 'blur(12px) brightness(2) saturate(2)';
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.filter = 'blur(2px) brightness(1.5) saturate(1.5)';
            tempCtx.drawImage(canvas, 0, 0);
            ctx.globalCompositeOperation = 'lighter';
            ctx.drawImage(tempCanvas, 0, 0);
            break;
        case 'Vignette':
            const gradientVignette = ctx.createRadialGradient(width / 2, height / 2, width / 4, width / 2, height / 2, width / 2);
            gradientVignette.addColorStop(0, 'rgba(0,0,0,0)');
            gradientVignette.addColorStop(1, 'rgba(0,0,0,0.7)');
            ctx.fillStyle = gradientVignette;
            ctx.fillRect(0, 0, width, height);
            break;
        case 'Film Grain':
            for (let i = 0; i < 2000; i++) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;
                ctx.fillRect(Math.random() * width, Math.random() * height, 1, 1);
            }
            break;
        case 'Echo Spin': {
            const { echoes = [] } = options || {};
            if (echoes.length === 0) break;

            const ECHO_LIFETIME = 8000;
            const FADE_IN_DURATION = 2500;
            const MAX_ALPHA = 0.35;
            const MAX_SCALE_ADDITION = 0.7;
            const MAX_BLUR = 10;
            const localEaseInOutSine = (x) => -(Math.cos(Math.PI * x) - 1) / 2;

            tempCtx.drawImage(canvas, 0, 0);

            const centerX = width / 2;
            const centerY = height / 2;
            const outerRadius = Math.min(width, height) / 2;
            const innerRadius = outerRadius * 0.7;
            
            const gradient = tempCtx.createRadialGradient(centerX, centerY, innerRadius, centerX, centerY, outerRadius);
            gradient.addColorStop(0, 'rgba(0,0,0,1)'); 
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.fillStyle = gradient;
            tempCtx.fillRect(0, 0, width, height);
            tempCtx.globalCompositeOperation = 'source-over';

            ctx.globalCompositeOperation = 'lighter';
            
            for (const echo of echoes) {
                const age = timestamp - echo.creationTimestamp;
                const lifetimeProgress = Math.min(1.0, age / ECHO_LIFETIME);
                
                let alpha = 0;
                if (age < FADE_IN_DURATION) {
                    const fadeInProgress = age / FADE_IN_DURATION;
                    alpha = localEaseInOutSine(fadeInProgress) * MAX_ALPHA;
                } else {
                    const fadeOutProgress = (age - FADE_IN_DURATION) / (ECHO_LIFETIME - FADE_IN_DURATION);
                    alpha = (1 - localEaseInOutSine(fadeOutProgress)) * MAX_ALPHA;
                }
                alpha = Math.max(0, alpha);

                const scale = 1.0 + lifetimeProgress * MAX_SCALE_ADDITION;
                
                const angle = (timestamp / 30000) * (echo.rotationSpeedMultiplier || 1);

                ctx.globalAlpha = alpha;
                ctx.filter = `blur(${lifetimeProgress * MAX_BLUR}px)`;

                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(angle);
                ctx.scale(scale, scale);
                ctx.translate(-width / 2, -height / 2);
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.restore();
            }
            break;
        }
        case 'Echo Scale': {
            const { echoes = [] } = options || {};
            if (echoes.length === 0) break;

            const ECHO_LIFETIME = 6000;
            const FADE_IN_DURATION = 1500;
            const MAX_ALPHA = 0.4;
            const MAX_SCALE_ADDITION = 1.0;
            const MAX_BLUR = 4;
            const localEaseInOutSine = (x) => -(Math.cos(Math.PI * x) - 1) / 2;

            tempCtx.drawImage(canvas, 0, 0);

            const centerX = width / 2;
            const centerY = height / 2;
            const outerRadius = Math.min(width, height) / 2;
            const innerRadius = outerRadius * 0.7;
            
            const gradient = tempCtx.createRadialGradient(centerX, centerY, innerRadius, centerX, centerY, outerRadius);
            gradient.addColorStop(0, 'rgba(0,0,0,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.fillStyle = gradient;
            tempCtx.fillRect(0, 0, width, height);
            tempCtx.globalCompositeOperation = 'source-over';

            ctx.globalCompositeOperation = 'lighter';
            
            for (const echo of echoes) {
                const age = timestamp - echo.creationTimestamp;
                const lifetimeProgress = Math.min(1.0, age / ECHO_LIFETIME);
                
                let alpha = 0;
                if (age < FADE_IN_DURATION) {
                    const fadeInProgress = age / FADE_IN_DURATION;
                    alpha = localEaseInOutSine(fadeInProgress) * MAX_ALPHA;
                } else {
                    const fadeOutProgress = (age - FADE_IN_DURATION) / (ECHO_LIFETIME - FADE_IN_DURATION);
                    alpha = (1 - localEaseInOutSine(fadeOutProgress)) * MAX_ALPHA;
                }
                alpha = Math.max(0, alpha);

                const scale = 1.0 + lifetimeProgress * MAX_SCALE_ADDITION;

                ctx.globalAlpha = alpha;
                ctx.filter = `blur(${lifetimeProgress * MAX_BLUR}px)`;

                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.scale(scale, scale);
                ctx.translate(-width / 2, -height / 2);
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.restore();
            }
            break;
        }
        case 'Prime Shader': {
            const { maxCount, colorTheme, animationStyle, viewState, host, lineWidth, isInterferenceEnabled } = options;
            const { rings, primes } = calculateWaveData(maxCount);

            // --- START VIEW STATE CORRECTION ---
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = width / dpr;
            const canvasHeight = height / dpr;
            
            ctx.scale(dpr,dpr); // Correct for HiDPI displays

            // 1. Calculate base zoom for the target (Wave)
            let baseWaveZoom = 1.0;
            if (primes.length > 0) {
                const lastPrimeIndex = primes.findIndex(p => p > maxCount);
                const relevantPrimes = lastPrimeIndex === -1 ? primes.length : lastPrimeIndex;
                const maxRadius = 50 + 3 * relevantPrimes + 5; // R_base, radial_growth, amplitude0
                const requiredDiameter = maxRadius * 2;
                baseWaveZoom = (requiredDiameter > 0) ? Math.min(canvasWidth / requiredDiameter, canvasHeight / requiredDiameter) * 3.0 : 1.0;
            }

            // 2. Calculate base zoom for the source (Host)
            let baseHostZoom = 1.0;
            if (host === 'spiral') {
                const pointSpacing = 12;
                const spiralDiameter = Math.sqrt(maxCount) * pointSpacing * 1.2;
                baseHostZoom = (spiralDiameter > 0) ? Math.min(canvasWidth / spiralDiameter, height / dpr / spiralDiameter) : 1.0;
            } else if (host === 'wave-field' && primes.length > 1) {
                const verticalSpacingScale = 3;
                const amplitude = 15;
                const yRange = (primes[primes.length - 1] - primes[0]) * verticalSpacingScale;
                baseHostZoom = (yRange > 0) ? Math.min(canvasHeight / (yRange + amplitude * 2), 0.2) : 0.2;
            } else if (host === 'wave') {
                baseHostZoom = baseWaveZoom;
            }

            // 3. Determine user's zoom interaction
            const userZoomRatio = baseHostZoom > 0.0001 ? viewState.zoom / baseHostZoom : 1.0;

            // 4. Calculate final corrected zoom for the overlay
            const finalZoom = baseWaveZoom * userZoomRatio;
            // --- END VIEW STATE CORRECTION ---
            
            if (waveOverlayState.lastAnimationStyle !== animationStyle) {
                waveOverlayState.cycleStartTimestamp = timestamp;
                waveOverlayState.lastAnimationStyle = animationStyle;
                if (animationStyle === 'Breathing Journey' && primes.length > 1) {
                    waveOverlayState.animatedCount = primes[1];
                } else {
                    waveOverlayState.animatedCount = 100;
                }
            }

            let animationZoomFactor = 1.0, breathingCue = '', fadeOpacity = 1.0, newestPrimeValue = -1, fadeInProgress = 1.0, speed = 1.0, isInhalePhase = false;
            const easeInOutSine = (x) => -(Math.cos(Math.PI * x) - 1) / 2;

            switch (animationStyle) {
                case 'Slow': speed = 0.5; break;
                case 'Pulse': speed = 1 + Math.sin(timestamp / 500) * 0.8; break;
                case 'Linear Journey': speed = 15; break;
                case 'Breathing Journey': case 'Breathe (Resonant)': {
                    const period = 10000, phaseDuration = period / 2, SHIFT_PER_PHASE = 150;
                    const cycleTime = (timestamp - waveOverlayState.cycleStartTimestamp) % period;
                    const cycleNumber = Math.floor((timestamp - waveOverlayState.cycleStartTimestamp) / period);
                    const baseOffset = cycleNumber * SHIFT_PER_PHASE * 2;
                    let currentOffset = baseOffset;
                    isInhalePhase = cycleTime < phaseDuration;
                    const phaseProgress = cycleTime % phaseDuration / phaseDuration;
                    if (isInhalePhase) currentOffset += easeInOutSine(phaseProgress) * SHIFT_PER_PHASE;
                    else currentOffset += SHIFT_PER_PHASE + easeInOutSine(phaseProgress) * SHIFT_PER_PHASE;
                    waveOverlayState.colorOffset = currentOffset;
                    const phase = (timestamp * 2 * Math.PI) / period;
                    animationZoomFactor = 1.0 + 0.03 * (1 - Math.cos(phase));
                    breathingCue = isInhalePhase ? 'Breathe In...' : 'Breathe Out...';
                    fadeOpacity = calculateFadeOpacity(cycleTime % phaseDuration, phaseDuration);
                    if (animationStyle === 'Breathing Journey') {
                        const primeIndex = (2 + cycleNumber - 1);
                        if (primeIndex < primes.length) {
                            waveOverlayState.animatedCount = primes[primeIndex];
                            newestPrimeValue = primes[primeIndex];
                        } else {
                            waveOverlayState.animatedCount = maxCount;
                        }
                        if (isInhalePhase) fadeInProgress = easeInOutSine(phaseProgress);
                    }
                    break;
                }
                case 'Breathe (4-7-8)': {
                    const cycleDuration = 19000, SHIFT_AMOUNT = 150;
                    const cycleProgress = (timestamp - waveOverlayState.cycleStartTimestamp) % cycleDuration;
                    const cycleNumber = Math.floor((timestamp - waveOverlayState.cycleStartTimestamp) / cycleDuration);
                    const baseOffset = cycleNumber * SHIFT_AMOUNT * 0.1;
                    const inhaleDuration = 4000, holdDuration = 7000, exhaleDuration = 8000;
                    isInhalePhase = cycleProgress < inhaleDuration;
                    if (isInhalePhase) {
                        const phaseProgress = cycleProgress / inhaleDuration;
                        waveOverlayState.colorOffset = baseOffset + easeInOutSine(phaseProgress) * SHIFT_AMOUNT;
                        animationZoomFactor = 1.0 + 0.05 * Math.sin(phaseProgress * (Math.PI / 2));
                        breathingCue = 'Breathe In...';
                        fadeOpacity = calculateFadeOpacity(cycleProgress, inhaleDuration);
                    } else if (cycleProgress < inhaleDuration + holdDuration) {
                        waveOverlayState.colorOffset = baseOffset + SHIFT_AMOUNT;
                        animationZoomFactor = 1.05;
                        breathingCue = 'Hold';
                        fadeOpacity = calculateFadeOpacity(cycleProgress - inhaleDuration, holdDuration);
                    } else {
                        const phaseProgress = (cycleProgress - (inhaleDuration + holdDuration)) / exhaleDuration;
                        waveOverlayState.colorOffset = baseOffset + SHIFT_AMOUNT - easeInOutSine(phaseProgress) * SHIFT_AMOUNT;
                        animationZoomFactor = 1.0 + 0.05 * Math.cos(phaseProgress * (Math.PI / 2));
                        breathingCue = 'Breathe Out...';
                        fadeOpacity = calculateFadeOpacity(cycleProgress - (inhaleDuration + holdDuration), exhaleDuration);
                    }
                    break;
                }
                case 'Breathe (Box)': {
                    const cycleDuration = 16000, SHIFT_AMOUNT = 150, phaseDuration = 4000;
                    const elapsedTime = timestamp - waveOverlayState.cycleStartTimestamp;
                    const continuousOffset = elapsedTime * ((SHIFT_AMOUNT * 0.1) / cycleDuration);
                    const cycleProgress = elapsedTime % cycleDuration;
                    const timeInPhase = cycleProgress % phaseDuration;
                    fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
                    let zoomProgress = 0, oscillatingOffset = 0;
                    isInhalePhase = cycleProgress < phaseDuration;
                    if (isInhalePhase) {
                        const phaseProgress = timeInPhase / phaseDuration;
                        oscillatingOffset = easeInOutSine(phaseProgress) * SHIFT_AMOUNT;
                        zoomProgress = easeInOutSine(phaseProgress);
                        breathingCue = 'Breathe In...';
                    } else if (cycleProgress < phaseDuration * 2) {
                        oscillatingOffset = SHIFT_AMOUNT;
                        zoomProgress = 1.0;
                        breathingCue = 'Hold';
                    } else if (cycleProgress < phaseDuration * 3) {
                        const phaseProgress = timeInPhase / phaseDuration;
                        oscillatingOffset = SHIFT_AMOUNT * (1 - easeInOutSine(phaseProgress));
                        zoomProgress = 1 - easeInOutSine(phaseProgress);
                        breathingCue = 'Breathe Out...';
                    } else {
                        oscillatingOffset = 0;
                        zoomProgress = 0;
                        breathingCue = 'Hold';
                    }
                    waveOverlayState.colorOffset = continuousOffset + oscillatingOffset;
                    animationZoomFactor = 1.0 + 0.05 * zoomProgress;
                    break;
                }
            }

            if (!animationStyle.startsWith('Breathe')) {
                waveOverlayState.colorOffset += speed;
            }

            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.save();
            ctx.translate(canvasWidth / 2, canvasHeight / 2);
            ctx.scale(finalZoom * animationZoomFactor, finalZoom * animationZoomFactor);
            ctx.lineWidth = (lineWidth || 1) / (finalZoom * animationZoomFactor);
            if (isInterferenceEnabled) {
                ctx.globalCompositeOperation = 'xor';
            }
            
            const currentAnimatedCount = animationStyle === 'Breathing Journey' ? waveOverlayState.animatedCount : maxCount;
            let i = 0;
            rings.forEach((points, prime) => {
                if (prime > currentAnimatedCount || points.length === 0) return;
                const colorIndex = Math.sqrt(prime) * 4;
                const getHue = primeWaveColorPalettes[colorTheme];
                const rawHue = getHue(colorIndex, waveOverlayState.colorOffset);
                const hue = rawHue < 0 ? (rawHue % 360) + 360 : rawHue % 360;
                let finalAlpha = 0.4; // alpha_ring
                if (animationStyle === 'Breathing Journey' && prime === newestPrimeValue && newestPrimeValue > primes[1]) {
                    finalAlpha *= fadeInProgress;
                }
                ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${finalAlpha})`;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let k = 1; k < points.length; k++) ctx.lineTo(points[k].x, points[k].y);
                ctx.closePath();
                ctx.stroke();
                i++;
            });
            ctx.restore();
            break;
        }
    }

    // --- Reset context state ---
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
    ctx.filter = 'none';
};

const useUnifiedInteraction = (canvasRef, viewState, setViewState, options = {}) => {
    const { onTapped } = options;
    const isInteracting = useRef(false);
    const interactionStart = useRef({ pointers: [], view: viewState });

    const getEventCoordinates = (e) => {
        if (e.touches) {
            return Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY }));
        }
        return [{ x: e.clientX, y: e.clientY }];
    };

    const handleInteractionStart = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        isInteracting.current = true;
        interactionStart.current = {
            pointers: getEventCoordinates(e),
            view: viewState,
        };
        if (canvasRef.current) canvasRef.current.style.cursor = 'grabbing';
    }, [viewState, canvasRef]);

    const handleInteractionMove = useCallback((e) => {
        if (!isInteracting.current) return;
        e.preventDefault();

        const currentPointers = getEventCoordinates(e);
        const startPointers = interactionStart.current.pointers;
        const startView = interactionStart.current.view;
        
        if (currentPointers.length !== startPointers.length) {
            interactionStart.current = { pointers: currentPointers, view: viewState };
            return;
        }

        if (currentPointers.length === 1) { // Pan
            const dx = currentPointers[0].x - startPointers[0].x;
            const dy = currentPointers[0].y - startPointers[0].y;
            setViewState({ ...startView, x: startView.x + dx, y: startView.y + dy });
        } else if (currentPointers.length >= 2) { // Pinch & Pan
            const p1Start = startPointers[0];
            const p2Start = startPointers[1];
            const p1Now = currentPointers[0];
            const p2Now = currentPointers[1];

            const distStart = Math.hypot(p1Start.x - p2Start.x, p1Start.y - p2Start.y);
            const distNow = Math.hypot(p1Now.x - p2Now.x, p1Now.y - p2Now.y);
            const scale = distStart > 0 ? distNow / distStart : 1;
            const newZoom = Math.max(0.01, Math.min(startView.zoom * scale, 100));

            const midStart = { x: (p1Start.x + p2Start.x) / 2, y: (p1Start.y + p2Start.y) / 2 };
            const midNow = { x: (p1Now.x + p2Now.x) / 2, y: (p1Now.y + p2Now.y) / 2 };

            const newX = midNow.x - (midStart.x - startView.x) * (newZoom / startView.zoom);
            const newY = midNow.y - (midStart.y - startView.y) * (newZoom / startView.zoom);

            setViewState({ zoom: newZoom, x: newX, y: newY });
        }
    }, [viewState, setViewState]);

    const handleInteractionEnd = useCallback((e) => {
        if (isInteracting.current) {
            if (onTapped) {
                const startPointers = interactionStart.current.pointers;
                if (startPointers.length === 1) {
                    const endPointer = e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
                    if (endPointer.clientX !== undefined) {
                        const dx = endPointer.clientX - startPointers[0].x;
                        const dy = endPointer.clientY - startPointers[0].y;
                        if (Math.hypot(dx, dy) < 10) { // 10px tolerance for a tap
                            onTapped();
                        }
                    }
                }
            }
            isInteracting.current = false;
            if (canvasRef.current) canvasRef.current.style.cursor = 'grab';
        }
    }, [canvasRef, onTapped]);
    
     const handleWheel = useCallback((e) => {
        e.preventDefault();
        if (!canvasRef.current) return;
        const rect = canvasRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const zoomFactor = 1.1;
        const delta = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
        setViewState(prev => {
          const newZoom = Math.max(0.01, Math.min(prev.zoom * delta, 100));
          const newX = mouseX - (mouseX - prev.x) * (newZoom / prev.zoom);
          const newY = mouseY - (mouseY - prev.y) * (newZoom / prev.zoom);
          return { x: newX, y: newY, zoom: newZoom };
        });
    }, [setViewState]);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        canvas.addEventListener('mousedown', handleInteractionStart, { passive: false });
        canvas.addEventListener('mousemove', handleInteractionMove, { passive: false });
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('mouseleave', handleInteractionEnd);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        canvas.addEventListener('touchcancel', handleInteractionEnd);

        return () => {
            canvas.removeEventListener('mousedown', handleInteractionStart);
            canvas.removeEventListener('mousemove', handleInteractionMove);
            canvas.removeEventListener('mouseup', handleInteractionEnd);
            canvas.removeEventListener('mouseleave', handleInteractionEnd);
            canvas.removeEventListener('wheel', handleWheel);

            canvas.removeEventListener('touchstart', handleInteractionStart);
            canvas.removeEventListener('touchmove', handleInteractionMove);
            canvas.removeEventListener('touchend', handleInteractionEnd);
            canvas.removeEventListener('touchcancel', handleInteractionEnd);
        };
    }, [canvasRef, handleInteractionStart, handleInteractionMove, handleInteractionEnd, handleWheel]);
};
// --- END SHARED UTILS ---


// Inlined from components/Controls.tsx
const Controls = ({
  value,
  setValue,
  amplitude,
  setAmplitude,
  lineWidth,
  setLineWidth,
  mode,
  colorTheme,
  setColorTheme,
  animationStyle,
  setAnimationStyle,
  shader,
  setShader,
  showBreathingText,
  setShowBreathingText,
  showJourneyPrime,
  setShowJourneyPrime,
  waveMotion,
  setWaveMotion,
  isToneEnabled,
  setIsToneEnabled,
  isInterferenceEnabled,
  setIsInterferenceEnabled,
  uiVisible,
}) => {
  const [copyButtonText, setCopyButtonText] = useState('Share');
  const maxLimit = 20000;
  const step = 100;

  const handleShare = () => {
    const params = new URLSearchParams();
    params.set('mode', mode);
    params.set('maxNumber', value);
    params.set('amplitude', amplitude);
    params.set('lineWidth', lineWidth);
    params.set('colorTheme', colorTheme);
    params.set('animationStyle', animationStyle);
    params.set('shader', shader);
    params.set('waveMotion', waveMotion);
    params.set('showBreathingText', showBreathingText);
    params.set('isToneEnabled', isToneEnabled);
    params.set('isInterferenceEnabled', isInterferenceEnabled);
    params.set('showJourneyPrime', showJourneyPrime);

    const baseUrl = 'https://prime-mind-938652442880.us-west1.run.app/';
    const shareUrl = `${baseUrl}?${params.toString()}`;
    
    navigator.clipboard.writeText(shareUrl).then(() => {
        setCopyButtonText('Copied!');
        setTimeout(() => setCopyButtonText('Share'), 2000);
    }).catch(err => {
        console.error('Failed to copy URL:', err);
        setCopyButtonText('Failed!');
        setTimeout(() => setCopyButtonText('Share'), 2000);
    });
  };

  return (
    <div
      className={`absolute bottom-4 left-1/2 -translate-x-1/2 z-10 bg-gray-800 bg-opacity-70 backdrop-blur-sm p-4 rounded-lg shadow-lg w-11/12 max-w-4xl transition-opacity duration-500 ${
        uiVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'
      }`}
    >
      <div className="flex flex-col gap-4">
        <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
          <label htmlFor="max-number-slider" className="font-medium text-gray-200 whitespace-nowrap text-sm">
            Prime Limit: <span className="font-bold text-yellow-300 w-20 inline-block text-center">{value}</span>
          </label>
          <input
            id="max-number-slider"
            type="range"
            min="100"
            max={mode === 'wave-field' ? 800 : maxLimit}
            step={step}
            value={value}
            onChange={(e) => setValue(parseInt(e.target.value, 10))}
            disabled={animationStyle === 'Linear Journey'}
            className="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-yellow-400 disabled:opacity-50 disabled:cursor-not-allowed"
          />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
            <div className="flex items-center gap-4">
                <label htmlFor="amplitude-slider" className="font-medium text-gray-200 whitespace-nowrap text-sm">
                Amplitude:
                </label>
                <input
                id="amplitude-slider"
                type="range"
                min="-17"
                max="17"
                step="0.1"
                value={amplitude}
                onChange={(e) => setAmplitude(parseFloat(e.target.value))}
                className="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-yellow-400"
                />
                <span className="font-bold text-yellow-300 w-12 text-center">{amplitude.toFixed(1)}</span>
            </div>
            <div className="flex items-center gap-4">
                <label htmlFor="linewidth-slider" className="font-medium text-gray-200 whitespace-nowrap text-sm">
                Line Width:
                </label>
                <input
                id="linewidth-slider"
                type="range"
                min="1"
                max="100"
                step="1"
                value={lineWidth}
                onChange={(e) => setLineWidth(parseInt(e.target.value, 10))}
                className="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-yellow-400"
                />
                <span className="font-bold text-yellow-300 w-12 text-center">{lineWidth}</span>
            </div>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-x-4 gap-y-3 mt-4">
        <div className="flex items-center gap-2">
          <label htmlFor="animation-style-select" className="font-medium text-gray-200 whitespace-nowrap text-sm">Experience:</label>
          <select id="animation-style-select" value={animationStyle} onChange={(e) => setAnimationStyle(e.target.value)} className="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-yellow-500 focus:border-yellow-500 p-2">
            <option value="Slow">Slow</option><option value="Pulse">Pulse</option><option value="Breathe (4-7-8)">Breathe (4-7-8)</option><option value="Breathe (Box)">Breathe (Box)</option><option value="Breathe (Resonant)">Breathe (Resonant)</option><option value="Breathing Journey">Breathing Journey</option><option value="Linear Journey">Linear Journey</option><option value="Sound Activated">Sound Activated</option>
          </select>
        </div>
         <div className="flex items-center gap-2">
            <label htmlFor="wave-motion-select" className="font-medium text-gray-200 whitespace-nowrap text-sm">Wave Motion:</label>
            <select id="wave-motion-select" value={waveMotion} onChange={(e) => setWaveMotion(e.target.value)} className="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-yellow-500 focus:border-yellow-500 p-2">
                <option value="Off">Off</option>
                <option value="Rotate">Rotate</option>
                <option value="Oscillate">Oscillate</option>
                <option value="Ripple">Ripple</option>
                <option value="Chaos">Chaos</option>
            </select>
        </div>
         <div className="flex items-center gap-2">
          <label htmlFor="shader-select" className="font-medium text-gray-200 whitespace-nowrap text-sm">Shader:</label>
          <select id="shader-select" value={shader} onChange={(e) => setShader(e.target.value)} className="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-yellow-500 focus:border-yellow-500 p-2">
            <option>None</option><option>Bloom</option><option>Neon</option><option>Vignette</option><option>Film Grain</option><option>Echo Spin</option><option>Echo Scale</option><option>Prime Shader</option>
          </select>
        </div>
        <div className="flex items-center gap-2">
          <label htmlFor="color-theme-select" className="font-medium text-gray-200 whitespace-nowrap text-sm">Theme:</label>
          <select id="color-theme-select" value={colorTheme} onChange={(e) => setColorTheme(e.target.value)} className="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-yellow-500 focus:border-yellow-500 p-2">
            <option>Spectrum</option><option>Ocean</option><option>Sunset</option><option>Forest</option><option>Earth</option><option>Autumn</option><option>Cyberpunk</option><option>Vaporwave</option>
          </select>
        </div>
      </div>
      <div className="mt-4 flex justify-center items-center gap-x-4 gap-y-2 flex-wrap">
        <div className="flex items-center gap-3">
          <label htmlFor="breathing-text-toggle" className="font-medium text-gray-200 text-sm">Breathing Cues</label>
          <button id="breathing-text-toggle" onClick={() => setShowBreathingText(!showBreathingText)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-yellow-500 ${showBreathingText ? 'bg-yellow-400' : 'bg-gray-600'}`} role="switch" aria-checked={showBreathingText}>
            <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${showBreathingText ? 'translate-x-6' : 'translate-x-1'}`}/>
          </button>
        </div>
        
        {animationStyle === 'Breathing Journey' && (
          <div className="flex items-center gap-3">
            <label htmlFor="journey-prime-toggle" className="font-medium text-gray-200 text-sm">Show Prime Number</label>
            <button id="journey-prime-toggle" onClick={() => setShowJourneyPrime(!showJourneyPrime)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-yellow-500 ${showJourneyPrime ? 'bg-yellow-400' : 'bg-gray-600'}`} role="switch" aria-checked={showJourneyPrime}>
              <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${showJourneyPrime ? 'translate-x-6' : 'translate-x-1'}`}/>
            </button>
          </div>
        )}
        
        <div className="flex items-center gap-3">
            <label htmlFor="tone-toggle" className="font-medium text-gray-200 text-sm">Prime Tones</label>
            <button id="tone-toggle" onClick={() => setIsToneEnabled(!isToneEnabled)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-yellow-500 ${isToneEnabled ? 'bg-yellow-400' : 'bg-gray-600'}`} role="switch" aria-checked={isToneEnabled}>
                <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${isToneEnabled ? 'translate-x-6' : 'translate-x-1'}`} />
            </button>
        </div>
        <div className="flex items-center gap-3">
          <label htmlFor="interference-toggle" className="font-medium text-gray-200 text-sm">Interference</label>
          <button id="interference-toggle" onClick={() => setIsInterferenceEnabled(!isInterferenceEnabled)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-yellow-500 ${isInterferenceEnabled ? 'bg-yellow-400' : 'bg-gray-600'}`} role="switch" aria-checked={isInterferenceEnabled}>
            <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${isInterferenceEnabled ? 'translate-x-6' : 'translate-x-1'}`} />
          </button>
        </div>
        <button onClick={handleShare} className="flex items-center gap-2 bg-yellow-400 text-gray-900 font-bold py-2 px-3 rounded-lg hover:bg-yellow-300 transition-colors text-sm">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg>
            <span>{copyButtonText}</span>
        </button>
      </div>
    </div>
  );
};

// Inlined from components/PrimeSpiral.tsx
const pointSpacing = 12;
const primeRadius = (pointSpacing * 0.7) / 2;
const nonPrimeRadius = (pointSpacing * 0.3) / 2;
const primeColor = '#FFD700';
const nonPrimeColor = '#444455';

const colorPalettes = {
  Spectrum: (i, offset) => -i * 2 + offset,
  Ocean: (i, offset) => 200 + Math.sin((i + offset * 0.1) * 0.05) * 40,
  Sunset: (i, offset) => 30 + Math.sin((i + offset * 0.1) * 0.04) * 30,
  Forest: (i, offset) => 120 + Math.sin((i + offset * 0.1) * 0.05) * 30,
  Earth: (i, offset) => 80 + Math.sin((i + offset * 0.05) * 0.1) * 20, // Greens and browns
  Autumn: (i, offset) => 30 + Math.sin((i + offset * 0.1) * 0.04) * 30, // Oranges and reds
  Cyberpunk: (i, offset) => 300 + Math.sin((i + offset * 0.1) * 0.03) * 60, // Pinks and purples
  Vaporwave: (i, offset) => 270 + Math.sin((i + offset * 0.1) * 0.05) * 40, // Pinks and blues
};

const PrimeSpiral = ({ count, animationStyle, colorTheme, shader, showBreathingText, showJourneyPrime, waveMotion, onVizTapped, toneService, amplitude, lineWidth, isInterferenceEnabled }) => {
  const canvasRef = useRef(null);
  const parentRef = useRef(null);
  const [viewState, setViewState] = useState({ x: 0, y: 0, zoom: 0.5 });
  const animationFrameId = useRef();
  const highlightProgressRef = useRef(0);
  const animationDirectionRef = useRef('forward');
  const timeRef = useRef(0);
  const animationStateRef = useRef({ cycleStartTimestamp: 0, lastToneTriggerValue: 0 });
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const audioStreamRef = useRef(null);
  const echoesRef = useRef([]);
  const justInhaledRef = useRef(false);
  const localEaseInOutSine = (x) => -(Math.cos(Math.PI * x) - 1) / 2;
  const lastPlayedPrimeIndexRef = useRef(-1);

  useUnifiedInteraction(canvasRef, viewState, setViewState, { onTapped: onVizTapped });

  const { pointMap, primes, primeNumberToIndex } = useMemo(() => {
    const maxCount = 250000;
    const primeSieve = getPrimeSieve(maxCount);

    const map = new Map();
    const primePoints = [];
    const primeIndexMap = new Map();
    let x = 0, y = 0, dx = 1, dy = 0;
    let segmentLength = 1, segmentPassed = 0, turnCounter = 0;

    for (let i = 1; i <= maxCount; i++) {
      const point = { x, y, number: i, isPrime: primeSieve[i] };
      map.set(`${x}|${y}`, point);
      if (point.isPrime) {
        primeIndexMap.set(point.number, primePoints.length);
        primePoints.push(point);
      }
      x += dx; y += dy; segmentPassed++;
      if (segmentPassed === segmentLength) {
        segmentPassed = 0; [dx, dy] = [-dy, dx]; turnCounter++;
        if (turnCounter === 2) { turnCounter = 0; segmentLength++; }
      }
    }
    return { pointMap: map, primes: primePoints, primeNumberToIndex: primeIndexMap };
  }, []);

    const journeyLimitIndex = useMemo(() => {
        if (animationStyle !== 'Linear Journey') return -1;
        const limitIndex = primes.findIndex(p => p.number > count);
        return limitIndex === -1 ? primes.length : limitIndex;
    }, [animationStyle, count, primes]);

    const resetViewState = useCallback(() => {
        if (parentRef.current) {
            const { width, height } = parentRef.current.getBoundingClientRect();
            const spiralDiameter = Math.sqrt(count) * pointSpacing * 1.2;
            const newZoom = Math.min(width / spiralDiameter, height / spiralDiameter);
            setViewState({ x: width / 2, y: height / 2, zoom: newZoom });
        }
    }, [count]);
    
  useEffect(() => {
      resetViewState();
  }, [count, resetViewState]);
  
  useEffect(() => {
    const handleResize = () => resetViewState();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [resetViewState]);

  useEffect(() => {
    animationStateRef.current.cycleStartTimestamp = timeRef.current;
    echoesRef.current = [];
    lastPlayedPrimeIndexRef.current = -1;
    if (animationStyle !== 'Sound Activated') {
        highlightProgressRef.current = 0;
        if (animationDirectionRef.current !== 'forward' && animationStyle === 'Linear Journey') {
            animationDirectionRef.current = 'forward';
            if(toneService) toneService.clearAllTones();
        }
    }
  }, [animationStyle, toneService]);

  useEffect(() => {
    const setupAudio = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStreamRef.current = stream;
        const context = new (window.AudioContext || window.webkitAudioContext)();
        audioContextRef.current = context;
        const source = context.createMediaStreamSource(stream);
        const analyser = context.createAnalyser();
        analyser.fftSize = 32;
        source.connect(analyser);
        analyserRef.current = analyser;
      } catch (err) {
        console.error('Microphone access denied:', err);
      }
    };
    const cleanupAudio = () => {
      audioStreamRef.current?.getTracks().forEach(track => track.stop());
      audioStreamRef.current = null;
      audioContextRef.current?.close();
      audioContextRef.current = null;
      analyserRef.current = null;
    };
    if (animationStyle === 'Sound Activated') {
      setupAudio();
    }
    return cleanupAudio;
  }, [animationStyle]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let animationRunning = true;
    
    const draw = (timestamp) => {
      if (!animationRunning) return;
      timeRef.current = timestamp;
       if (animationStateRef.current.cycleStartTimestamp === 0) {
        animationStateRef.current.cycleStartTimestamp = timestamp;
      }

      let progressRate = 0;
      let breathingCue = '';
      let fadeOpacity = 1.0;
      let newestPrimeValue = -1;
      let fadeInProgress = 1.0;
      let isInhalePhase = false;

      switch (animationStyle) {
        case 'Slow': progressRate = 0.1; break;
        case 'Pulse': progressRate = (1 + Math.sin(timestamp / 300)) * 0.5; break;
        case 'Linear Journey': {
            const journeyDurationSeconds = 90;
            const totalFrames = journeyDurationSeconds * 60; // Approximation
            progressRate = journeyLimitIndex > 0 ? (journeyLimitIndex / totalFrames) : 0.5;
            break;
        }
        case 'Breathe (Resonant)': {
          const period = 10000;
          const phaseDuration = period / 2;
          const phase = (timestamp * 2 * Math.PI) / period;
          progressRate = 0.15 * (1 + Math.sin(phase));
          const cycleTime = (timestamp - animationStateRef.current.cycleStartTimestamp) % period;
          isInhalePhase = cycleTime < phaseDuration;
          const timeInPhase = cycleTime % phaseDuration;
          fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
          breathingCue = isInhalePhase ? 'Breathe In...' : 'Breathe Out...';
          break;
        }
        case 'Breathe (4-7-8)': {
          const cycleDuration = 19000;
          const cycleProgress = (timestamp - animationStateRef.current.cycleStartTimestamp) % cycleDuration;
          const inhaleDuration = 4000;
          const holdDuration = 7000;
          const exhaleDuration = 8000;
          
          isInhalePhase = cycleProgress < inhaleDuration;
          if (isInhalePhase) {
            progressRate = 0.2; breathingCue = 'Breathe In...';
            fadeOpacity = calculateFadeOpacity(cycleProgress, inhaleDuration);
          } else if (cycleProgress < inhaleDuration + holdDuration) {
            progressRate = 0; breathingCue = 'Hold';
            const timeInPhase = cycleProgress - inhaleDuration;
            fadeOpacity = calculateFadeOpacity(timeInPhase, holdDuration);
          } else {
            progressRate = 0.1; breathingCue = 'Breathe Out...';
            const timeInPhase = cycleProgress - (inhaleDuration + holdDuration);
            fadeOpacity = calculateFadeOpacity(timeInPhase, exhaleDuration);
          }
          break;
        }
        case 'Breathe (Box)': {
            const cycleDuration = 16000;
            const phaseDuration = 4000;
            const H_AMOUNT = 15; // Amplitude of primes for breathing
            const DRIFT_PER_CYCLE = 5; // Slow outward drift

            const elapsedTime = timestamp - animationStateRef.current.cycleStartTimestamp;
            
            const continuousHighlightProgress = (elapsedTime / cycleDuration) * DRIFT_PER_CYCLE;
            
            const cycleProgress = elapsedTime % cycleDuration;
            const timeInPhase = cycleProgress % phaseDuration;
            fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
            
            let oscillatingHighlightProgress = 0;
            
            isInhalePhase = cycleProgress < phaseDuration;
            if (isInhalePhase) { // Inhale
                const phaseProgress = timeInPhase / phaseDuration;
                oscillatingHighlightProgress = localEaseInOutSine(phaseProgress) * H_AMOUNT;
                breathingCue = 'Breathe In...';
            } else if (cycleProgress < phaseDuration * 2) { // Hold In
                oscillatingHighlightProgress = H_AMOUNT;
                breathingCue = 'Hold';
            } else if (cycleProgress < phaseDuration * 3) { // Exhale
                const phaseProgress = timeInPhase / phaseDuration;
                oscillatingHighlightProgress = (1 - localEaseInOutSine(phaseProgress)) * H_AMOUNT;
                breathingCue = 'Breathe Out...';
            } else { // Hold Out
                oscillatingHighlightProgress = 0;
                breathingCue = 'Hold'; 
            }
            
            highlightProgressRef.current = continuousHighlightProgress + oscillatingHighlightProgress;
            progressRate = 0; 
            break;
        }
        case 'Breathing Journey': {
            const period = 10000;
            const phaseDuration = period / 2;
            const cycleTime = (timestamp - animationStateRef.current.cycleStartTimestamp) % period;
            const cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / period);
            isInhalePhase = cycleTime < phaseDuration;
            const timeInPhase = cycleTime % phaseDuration;
            const phaseProgress = timeInPhase / phaseDuration;
            
            const targetPrimeIndex = cycleNumber + 1;
            if (targetPrimeIndex > highlightProgressRef.current) {
                highlightProgressRef.current += 0.2; 
            }
             if (highlightProgressRef.current > targetPrimeIndex) {
                highlightProgressRef.current = targetPrimeIndex;
            }

            if (targetPrimeIndex < primes.length) {
                newestPrimeValue = primes[targetPrimeIndex]?.number;
            }

            breathingCue = isInhalePhase ? 'Breathe In...' : 'Breathe Out...';
            fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
            if (isInhalePhase) fadeInProgress = localEaseInOutSine(phaseProgress);
            break;
        }
        case 'Sound Activated':
          if (analyserRef.current) {
            const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
            analyserRef.current.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            progressRate = (avg / 128) * 0.8;
          }
          break;
      }
      
      let isNewInhaleEvent = false;
      if (isInhalePhase && !justInhaledRef.current) {
          isNewInhaleEvent = true;
          justInhaledRef.current = true;
      } else if (!isInhalePhase) {
          justInhaledRef.current = false;
      }

      if (shader === 'Echo Spin' || shader === 'Echo Scale') {
        const ECHO_LIFETIME = 8000;
        echoesRef.current = echoesRef.current.filter(e => timestamp - e.creationTimestamp < ECHO_LIFETIME);
        if (isNewInhaleEvent) {
            echoesRef.current.push({
                creationTimestamp: timestamp,
                rotationSpeedMultiplier: 1 + (Math.random() - 0.5) * 0.4
            });
        }
      } else {
        echoesRef.current = [];
      }
      
      if (animationStyle === 'Linear Journey') {
          if (animationDirectionRef.current === 'forward') {
              highlightProgressRef.current += progressRate;
              if (highlightProgressRef.current >= journeyLimitIndex) {
                  highlightProgressRef.current = journeyLimitIndex;
                  animationDirectionRef.current = 'backward';
                  if(toneService) toneService.clearAllTones();
              }
          } else { // backward
              highlightProgressRef.current -= progressRate;
              if (highlightProgressRef.current <= 0) {
                  highlightProgressRef.current = 0;
                  animationDirectionRef.current = 'forward';
                  if(toneService) toneService.clearAllTones();
              }
          }
      } else if (animationStyle !== 'Breathing Journey' && animationStyle !== 'Breathe (Box)') {
        if (animationDirectionRef.current === 'forward') {
            highlightProgressRef.current += progressRate;
            if (highlightProgressRef.current > primes.length) {
            highlightProgressRef.current = primes.length;
            animationDirectionRef.current = 'backward';
            }
        } else {
            highlightProgressRef.current -= progressRate;
            if (highlightProgressRef.current < 0) {
            highlightProgressRef.current = 0;
            animationDirectionRef.current = 'forward';
            }
        }
      }

      if (toneService) {
        let primeToPlay = null;
        if (animationStyle.startsWith('Breathe')) {
          if(isNewInhaleEvent) {
            let cycleNumber = 0;
            if(animationStyle === 'Breathing Journey') {
              cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / 10000);
              primeToPlay = primes[cycleNumber + 1]?.number;
            } else {
              let cycleDuration = 10000;
              if (animationStyle === 'Breathe (4-7-8)') cycleDuration = 19000;
              if (animationStyle === 'Breathe (Box)') cycleDuration = 16000;
              cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / cycleDuration);
              primeToPlay = primes[cycleNumber % primes.length]?.number;
            }
          }
        } else if (animationStyle === 'Linear Journey') {
           const currentIndex = Math.floor(highlightProgressRef.current);
           if (currentIndex !== lastPlayedPrimeIndexRef.current && currentIndex >= 0 && currentIndex < journeyLimitIndex) {
             primeToPlay = primes[currentIndex]?.number;
             lastPlayedPrimeIndexRef.current = currentIndex;
           }
        } else if (animationStyle === 'Sound Activated') {
           if (progressRate > 0.6 && timestamp - animationStateRef.current.lastToneTriggerValue > 500) {
             const primeIndex = Math.floor((progressRate / 0.8) * primes.length * 0.1);
             primeToPlay = primes[primeIndex]?.number;
             animationStateRef.current.lastToneTriggerValue = timestamp;
           }
        } else { // Slow, Pulse
           const TONE_INTERVAL = animationStyle === 'Pulse' ? 5 : 10;
           const currentInterval = Math.floor(highlightProgressRef.current / TONE_INTERVAL);
           if (currentInterval !== animationStateRef.current.lastToneTriggerValue) {
             const primeIndex = Math.floor(highlightProgressRef.current);
             if (primeIndex >= 0 && primeIndex < primes.length) {
               primeToPlay = primes[primeIndex]?.number;
               animationStateRef.current.lastToneTriggerValue = currentInterval;
             }
           }
        }

        if (primeToPlay) toneService.play(primeToPlay);
      }

      const dpr = window.devicePixelRatio || 1;
      const rect = parentRef.current.getBoundingClientRect();
      if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }
      
      ctx.save();
      ctx.fillStyle = '#111827';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.scale(dpr, dpr);

      if (shader !== 'Prime Shader') {
        ctx.translate(viewState.x, viewState.y);
        ctx.scale(viewState.zoom, viewState.zoom);
        
        const viewPortLeft = -viewState.x / viewState.zoom;
        const viewPortTop = -viewState.y / viewState.zoom;
        const viewPortRight = (rect.width - viewState.x) / viewState.zoom;
        const viewPortBottom = (rect.height - viewState.y) / viewState.zoom;

        const minGridX = Math.floor(viewPortLeft / pointSpacing) - 1;
        const maxGridX = Math.ceil(viewPortRight / pointSpacing) + 1;
        const minGridY = Math.floor(viewPortTop / pointSpacing) - 1;
        const maxGridY = Math.ceil(viewPortBottom / pointSpacing) + 1;

        const useRects = viewState.zoom < 0.15;
        const rectSize = 1 / viewState.zoom;

        for (let gridY = minGridY; gridY <= maxGridY; gridY++) {
          for (let gridX = minGridX; gridX <= maxGridX; gridX++) {
              const point = pointMap.get(`${gridX}|${gridY}`);
              if (!point || point.number > count) continue;
              
              let color = nonPrimeColor;
              if(point.isPrime) {
                  const primeIndex = primeNumberToIndex.get(point.number);
                  if (primeIndex !== undefined && primeIndex < highlightProgressRef.current) {
                      color = primeColor;
                  }
              }
              ctx.fillStyle = color;

              if (useRects) {
                ctx.fillRect(point.x * pointSpacing - rectSize / 2, point.y * pointSpacing - rectSize / 2, rectSize, rectSize);
              } else {
                ctx.beginPath();
                const radius = point.isPrime ? primeRadius : nonPrimeRadius;
                ctx.arc(point.x * pointSpacing, point.y * pointSpacing, radius, 0, 2 * Math.PI);
                ctx.fill();
              }
          }
        }
        
        const tailLength = 15;
        const currentIndex = Math.floor(highlightProgressRef.current);
        const finalAmplitude = 1 + (amplitude - 1) * 0.75;
        for (let i = 0; i < tailLength; i++) {
          const primeIndex = animationDirectionRef.current === 'forward' || animationStyle === 'Breathing Journey' || animationStyle === 'Linear Journey' ? currentIndex - i : currentIndex + i;
          if (primeIndex < 0 || primeIndex >= primes.length) continue;
          const point = primes[primeIndex];
          if (point.number > count) continue;

          const opacity = Math.max(0, 1 - (i / tailLength));
          const radius = primeRadius * (2.5 - (i / tailLength) * 1.5) * Math.abs(finalAmplitude);
          
          const colorIndex = Math.sqrt(point.number) * 4;
          const getHue = colorPalettes[colorTheme];
          const rawHue = getHue(colorIndex, timeRef.current / 20);
          const hue = rawHue < 0 ? (rawHue % 360) + 360 : rawHue % 360;

          ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${opacity})`;
          ctx.shadowColor = `hsla(${hue}, 100%, 70%, 1)`;
          ctx.shadowBlur = (1 - (i / tailLength)) * 15 / viewState.zoom * Math.abs(finalAmplitude);
          
          ctx.beginPath();
          ctx.arc(point.x * pointSpacing, point.y * pointSpacing, radius, 0, 2 * Math.PI);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }
      ctx.restore();

      applyShader(ctx, shader, timestamp, { 
          echoes: echoesRef.current,
          maxCount: count,
          colorTheme,
          animationStyle,
          viewState,
          host: 'spiral',
          lineWidth,
          isInterferenceEnabled
      });

      ctx.save();
      ctx.scale(dpr, dpr);
      const textX = (canvas.width / dpr) / 2;
      const textY = (canvas.height / dpr) / 2;

      if (showBreathingText && breathingCue) {
        ctx.font = 'normal 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.shadowColor = `rgba(0, 0, 0, ${0.9 * fadeOpacity})`;
        ctx.shadowBlur = 8;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * fadeOpacity})`;
        ctx.fillText(breathingCue, textX, textY);

        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
      }
        if (showJourneyPrime && animationStyle === 'Breathing Journey' && newestPrimeValue > -1) {
            ctx.font = '12px "Courier New", monospace';
            ctx.fillStyle = `rgba(255, 215, 0, ${0.5 * fadeInProgress * fadeOpacity})`;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
            ctx.fillText(`+ ${newestPrimeValue}`, textX, textY + 25);
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }
      ctx.restore();

      animationFrameId.current = requestAnimationFrame(draw);
    };

    animationFrameId.current = requestAnimationFrame(draw);
    return () => { 
        animationRunning = false;
        if(animationFrameId.current) cancelAnimationFrame(animationFrameId.current)
    }
  }, [count, pointMap, viewState, primes, animationStyle, colorTheme, shader, primeNumberToIndex, showBreathingText, showJourneyPrime, journeyLimitIndex, toneService, amplitude, lineWidth, isInterferenceEnabled]);

  return (
    <div
      ref={parentRef}
      className="w-full h-full relative cursor-grab touch-none select-none overflow-hidden"
    >
      <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full" />
    </div>
  );
};


// Inlined from components/PrimeWave.tsx
const thetaSamples = 500;
const R_base = 50;
const radial_growth_per_prime = 3;
const amplitude0 = 5;
const alpha_ring = 0.4;

const primeWaveColorPalettes = {
  Spectrum: (i, offset) => -i * 10 + offset,
  Ocean: (i, offset) => 200 + Math.sin((i + offset * 0.1) * 0.1) * 40,
  Sunset: (i, offset) => 30 + Math.sin((i + offset * 0.1) * 0.08) * 30,
  Forest: (i, offset) => 120 + Math.sin((i + offset * 0.1) * 0.1) * 30,
  Earth: (i, offset) => 80 + Math.sin((i + offset * 0.05) * 0.1) * 20, 
  Autumn: (i, offset) => 30 + Math.sin((i + offset * 0.1) * 0.08) * 30, 
  Cyberpunk: (i, offset) => 300 + Math.sin((i + offset * 0.1) * 0.06) * 60,
  Vaporwave: (i, offset) => 270 + Math.sin((i + offset * 0.1) * 0.1) * 40,
};

const easeInOutSine = (x) => -(Math.cos(Math.PI * x) - 1) / 2;

const PrimeWave = ({ maxCount, colorTheme, animationStyle, shader, showBreathingText, showJourneyPrime, waveMotion, onVizTapped, toneService, amplitude, lineWidth, isInterferenceEnabled }) => {
  const canvasRef = useRef(null);
  const parentRef = useRef(null);
  const [viewState, setViewState] = useState({ x: 0, y: 0, zoom: 1.0 });
  const animationFrameId = useRef();
  const colorOffsetRef = useRef(0);
  const timeRef = useRef(0);
  const animationStateRef = useRef({ cycleStartTimestamp: 0, lastToneTriggerValue: 0 });
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const audioStreamRef = useRef(null);
  const animatedCountRef = useRef(100);
  const echoesRef = useRef([]);
  const justInhaledRef = useRef(false);
  const animationDirectionRef = useRef('forward');
  const activeWavePhaseRef = useRef(0);
  const lastPlayedPrimeRef = useRef(-1);

  useUnifiedInteraction(canvasRef, viewState, setViewState, { onTapped: onVizTapped });

  const { rings, primes } = useMemo(() => {
    const primeSieve = getPrimeSieve(maxCount);
    const primeList = [];
    for (let i = 2; i <= maxCount; i++) {
      if (primeSieve[i]) {
        primeList.push(i);
      }
    }
    const calculatedRings = new Map();
    const theta = Array.from({ length: thetaSamples }, (_, i) => (i / (thetaSamples - 1)) * 2 * Math.PI);
    primeList.forEach((p, i) => {
      const points = [];
      const R_i = R_base + radial_growth_per_prime * i;
      for (let j = 0; j < thetaSamples; j++) {
        const angle = theta[j];
        const r = R_i + (amplitude0 * amplitude) * Math.sin(p * angle);
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        points.push({ x, y });
      }
      calculatedRings.set(p, points);
    });
    return { rings: calculatedRings, primes: primeList };
  }, [maxCount, amplitude]);

  const resetViewState = useCallback(() => {
    if (parentRef.current && primes.length > 0) {
        const { width, height } = parentRef.current.getBoundingClientRect();
        const lastPrimeIndex = primes.findIndex(p => p > maxCount);
        const relevantPrimes = lastPrimeIndex === -1 ? primes.length : lastPrimeIndex;
        const maxRadius = R_base + radial_growth_per_prime * relevantPrimes + (amplitude0 * amplitude);
        const requiredDiameter = maxRadius * 2;
        const newZoom = Math.min(width / requiredDiameter, height / requiredDiameter) * 3.0;
        setViewState({ x: width / 2, y: height / 2, zoom: newZoom });
    } else if (parentRef.current) {
        const { width, height } = parentRef.current.getBoundingClientRect();
        setViewState({ x: width / 2, y: height / 2, zoom: 1.0 });
    }
  }, [maxCount, primes, amplitude]);
  
  useEffect(() => {
      resetViewState();
  }, [maxCount, resetViewState]);
  
  useEffect(() => {
    const handleResize = () => resetViewState();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [resetViewState]);

  useEffect(() => {
    animationStateRef.current.cycleStartTimestamp = timeRef.current;
    echoesRef.current = [];
    lastPlayedPrimeRef.current = -1;
    activeWavePhaseRef.current = 0;
    if (animationStyle === 'Breathing Journey' && primes.length > 1) {
      animatedCountRef.current = primes[1];
    } else if (animationStyle === 'Linear Journey') {
      animatedCountRef.current = 0;
      if (animationDirectionRef.current !== 'forward') {
          animationDirectionRef.current = 'forward';
          if(toneService) toneService.clearAllTones();
      }
    } else {
      animatedCountRef.current = maxCount;
    }
  }, [animationStyle, primes, maxCount, toneService, waveMotion]);

  useEffect(() => {
    const setupAudio = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStreamRef.current = stream;
        const context = new (window.AudioContext || window.webkitAudioContext)();
        audioContextRef.current = context;
        const source = context.createMediaStreamSource(stream);
        const analyser = context.createAnalyser();
        analyser.fftSize = 32;
        source.connect(analyser);
        analyserRef.current = analyser;
      } catch (err) {
        console.error('Microphone access denied:', err);
      }
    };
    const cleanupAudio = () => {
      audioStreamRef.current?.getTracks().forEach(track => track.stop());
      audioStreamRef.current = null;
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        audioContextRef.current.close();
      }
      audioContextRef.current = null;
      analyserRef.current = null;
    };
    if (animationStyle === 'Sound Activated') {
      setupAudio();
    }
    return () => {
      cleanupAudio();
    };
  }, [animationStyle]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    let animationRunning = true;

    const draw = (timestamp) => {
      if (!animationRunning) return;
      timeRef.current = timestamp;
      if (animationStateRef.current.cycleStartTimestamp === 0) {
        animationStateRef.current.cycleStartTimestamp = timestamp;
      }

      if (waveMotion === 'Rotate') {
        activeWavePhaseRef.current += 0.02;
      } else {
        activeWavePhaseRef.current = 0;
      }

      let animationZoomFactor = 1.0;
      let breathingCue = '';
      let fadeOpacity = 1.0;
      let newestPrimeValue = -1;
      let fadeInProgress = 1.0;
      let speed = 1.0;
      let isInhalePhase = false;

      switch (animationStyle) {
        case 'Slow':
          speed = 0.5;
          break;
        case 'Pulse':
          speed = 1 + Math.sin(timeRef.current / 500) * 0.8;
          break;
        case 'Linear Journey': {
            const journeyDurationSeconds = 90;
            const totalFrames = journeyDurationSeconds * 60; // approx 60fps
            const progressPerFrame = maxCount / totalFrames;
            
            if (animationDirectionRef.current === 'forward') {
                animatedCountRef.current += progressPerFrame;
                if (animatedCountRef.current >= maxCount) {
                    animatedCountRef.current = maxCount;
                    animationDirectionRef.current = 'backward';
                    if(toneService) toneService.clearAllTones();
                }
            } else { // backward
                animatedCountRef.current -= progressPerFrame;
                if (animatedCountRef.current <= 0) {
                    animatedCountRef.current = 0;
                    animationDirectionRef.current = 'forward';
                    if(toneService) toneService.clearAllTones();
                }
            }
            speed = 15;
          }
          break;
        case 'Breathing Journey':
        case 'Breathe (Resonant)':
          {
            const period = 10000;
            const phaseDuration = period / 2;
            const SHIFT_PER_PHASE = 150;
            const cycleTime = (timestamp - animationStateRef.current.cycleStartTimestamp) % period;
            const cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / period);
            const baseOffset = cycleNumber * SHIFT_PER_PHASE * 2;
            let currentOffset = baseOffset;
            isInhalePhase = cycleTime < phaseDuration;
            const timeInPhase = cycleTime % phaseDuration;
            const phaseProgress = timeInPhase / phaseDuration;
            if (isInhalePhase) {
              currentOffset += easeInOutSine(phaseProgress) * SHIFT_PER_PHASE;
            } else {
              currentOffset += SHIFT_PER_PHASE;
              currentOffset += easeInOutSine(phaseProgress) * SHIFT_PER_PHASE;
            }
            colorOffsetRef.current = currentOffset;
            const phase = (timestamp * 2 * Math.PI) / period;
            animationZoomFactor = 1.0 + 0.03 * (1 - Math.cos(phase));
            breathingCue = isInhalePhase ? 'Breathe In...' : 'Breathe Out...';
            fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
            if (animationStyle === 'Breathing Journey') {
              const currentCycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / period);
              const basePrimeCount = 2;
              const primeIndex = basePrimeCount + currentCycleNumber - 1;
              if (primeIndex < primes.length) {
                animatedCountRef.current = primes[primeIndex];
                newestPrimeValue = primes[primeIndex];
              } else {
                animatedCountRef.current = maxCount;
              }
              if(isInhalePhase) {
                fadeInProgress = easeInOutSine(phaseProgress);
              }
            }
          }
          break;
        case 'Breathe (4-7-8)':
          {
            const cycleDuration = 19000;
            const SHIFT_AMOUNT = 150;
            const cycleProgress = (timestamp - animationStateRef.current.cycleStartTimestamp) % cycleDuration;
            const cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / cycleDuration);
            const baseOffset = cycleNumber * SHIFT_AMOUNT * 0.1;
            const inhaleDuration = 4000;
            const holdDuration = 7000;
            const exhaleDuration = 8000;
            isInhalePhase = cycleProgress < inhaleDuration;
            if (isInhalePhase) {
              const phaseProgress = cycleProgress / inhaleDuration;
              colorOffsetRef.current = baseOffset + easeInOutSine(phaseProgress) * SHIFT_AMOUNT;
              animationZoomFactor = 1.0 + 0.05 * Math.sin(phaseProgress * (Math.PI / 2));
              breathingCue = 'Breathe In...';
              fadeOpacity = calculateFadeOpacity(cycleProgress, inhaleDuration);
            } else if (cycleProgress < inhaleDuration + holdDuration) {
              colorOffsetRef.current = baseOffset + SHIFT_AMOUNT;
              animationZoomFactor = 1.05;
              breathingCue = 'Hold';
              const timeInPhase = cycleProgress - inhaleDuration;
              fadeOpacity = calculateFadeOpacity(timeInPhase, holdDuration);
            } else {
              const phaseProgress = (cycleProgress - (inhaleDuration + holdDuration)) / exhaleDuration;
              colorOffsetRef.current = baseOffset + SHIFT_AMOUNT - easeInOutSine(phaseProgress) * SHIFT_AMOUNT;
              animationZoomFactor = 1.0 + 0.05 * Math.cos(phaseProgress * (Math.PI / 2));
              breathingCue = 'Breathe Out...';
              const timeInPhase = cycleProgress - (inhaleDuration + holdDuration);
              fadeOpacity = calculateFadeOpacity(timeInPhase, exhaleDuration);
            }
          }
          break;
        case 'Breathe (Box)':
          {
              const cycleDuration = 16000;
              const SHIFT_AMOUNT = 150;
              const elapsedTime = timestamp - animationStateRef.current.cycleStartTimestamp;
              
              const driftRate = (SHIFT_AMOUNT * 0.1) / cycleDuration;
              const continuousOffset = elapsedTime * driftRate;

              const phaseDuration = 4000;
              const cycleProgress = elapsedTime % cycleDuration;
              const timeInPhase = cycleProgress % phaseDuration;
              fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
              
              let zoomProgress = 0;
              let oscillatingOffset = 0;

              isInhalePhase = cycleProgress < phaseDuration;
              if (isInhalePhase) { // Inhale
                  const phaseProgress = timeInPhase / phaseDuration;
                  oscillatingOffset = easeInOutSine(phaseProgress) * SHIFT_AMOUNT;
                  zoomProgress = easeInOutSine(phaseProgress);
                  breathingCue = 'Breathe In...';
              } else if (cycleProgress < phaseDuration * 2) { // Hold In
                  oscillatingOffset = SHIFT_AMOUNT;
                  zoomProgress = 1.0;
                  breathingCue = 'Hold';
              } else if (cycleProgress < phaseDuration * 3) { // Exhale
                  const phaseProgress = timeInPhase / phaseDuration;
                  oscillatingOffset = SHIFT_AMOUNT * (1 - easeInOutSine(phaseProgress));
                  zoomProgress = 1 - easeInOutSine(phaseProgress);
                  breathingCue = 'Breathe Out...';
              } else { // Hold Out
                  oscillatingOffset = 0;
                  zoomProgress = 0;
                  breathingCue = 'Hold';
              }

              colorOffsetRef.current = continuousOffset + oscillatingOffset;
              animationZoomFactor = 1.0 + 0.05 * zoomProgress;
          }
          break;
        case 'Sound Activated':
          if (analyserRef.current) {
            const bufferLength = analyserRef.current.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyserRef.current.getByteFrequencyData(dataArray);
            const sum = dataArray.reduce((a, b) => a + b, 0);
            const avg = sum / bufferLength || 0;
            const normalizedAvg = avg / 128; 
            speed = normalizedAvg * 5;
          }
          break;
      }
      
      let isNewInhaleEvent = false;
      if (isInhalePhase && !justInhaledRef.current) {
          isNewInhaleEvent = true;
          justInhaledRef.current = true;
      } else if (!isInhalePhase) {
          justInhaledRef.current = false;
      }
      
      if (shader === 'Echo Spin' || shader === 'Echo Scale') {
        const ECHO_LIFETIME = 8000;
        echoesRef.current = echoesRef.current.filter(e => timestamp - e.creationTimestamp < ECHO_LIFETIME);
        if (isNewInhaleEvent) {
            echoesRef.current.push({
                creationTimestamp: timestamp,
                rotationSpeedMultiplier: 1 + (Math.random() - 0.5) * 0.4
            });
        }
      } else {
        echoesRef.current = [];
      }

      if (!animationStyle.startsWith('Breathe')) {
          colorOffsetRef.current += speed;
      }

      if (toneService) {
          let primeToPlay = null;
          if (animationStyle === 'Breathing Journey') {
              if (newestPrimeValue > -1 && newestPrimeValue !== lastPlayedPrimeRef.current) {
                  primeToPlay = newestPrimeValue;
                  lastPlayedPrimeRef.current = newestPrimeValue;
              }
          } else if (animationStyle.startsWith('Breathe')) {
              if (isNewInhaleEvent) {
                  let cycleDuration = 10000;
                  if (animationStyle === 'Breathe (4-7-8)') cycleDuration = 19000;
                  if (animationStyle === 'Breathe (Box)') cycleDuration = 16000;
                  const cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / cycleDuration);
                  primeToPlay = primes[cycleNumber % primes.length];
              }
          } else if (animationStyle === 'Linear Journey') {
              const currentPrime = primes.find(p => p > animatedCountRef.current);
              if(currentPrime && currentPrime !== lastPlayedPrimeRef.current) {
                  primeToPlay = currentPrime;
                  lastPlayedPrimeRef.current = currentPrime;
              }
          } else if (animationStyle === 'Sound Activated') {
              if (speed > 3 && timestamp - animationStateRef.current.lastToneTriggerValue > 500) {
                  const primeIndex = Math.floor((speed / 5) * primes.length * 0.1);
                  primeToPlay = primes[primeIndex];
                  animationStateRef.current.lastToneTriggerValue = timestamp;
              }
          } else { // Slow, Pulse
              const TONE_INTERVAL = 360;
              const currentInterval = Math.floor(colorOffsetRef.current / TONE_INTERVAL);
              if (currentInterval !== animationStateRef.current.lastToneTriggerValue) {
                  const primeIndex = currentInterval % primes.length;
                  primeToPlay = primes[primeIndex];
                  animationStateRef.current.lastToneTriggerValue = currentInterval;
              }
          }
          if(primeToPlay) toneService.play(primeToPlay);
      }

      const dpr = window.devicePixelRatio || 1;
      const rect = parentRef.current.getBoundingClientRect();
      if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }

      ctx.save();
      ctx.fillStyle = '#111827';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.scale(dpr, dpr);

      if (shader !== 'Prime Shader') {
        ctx.translate(viewState.x, viewState.y);
        ctx.scale(viewState.zoom * animationZoomFactor, viewState.zoom * animationZoomFactor);
        ctx.lineWidth = lineWidth / (viewState.zoom * animationZoomFactor);
        if (isInterferenceEnabled) {
            ctx.globalCompositeOperation = 'xor';
        }
        const currentAnimatedCount = (animationStyle === 'Breathing Journey' || animationStyle === 'Linear Journey') 
            ? animatedCountRef.current 
            : maxCount;
        
        if (waveMotion !== 'Off') {
            const theta = Array.from({ length: thetaSamples }, (_, i) => (i / (thetaSamples - 1)) * 2 * Math.PI);
            let i = 0;
            primes.forEach((prime) => {
                if (prime > currentAnimatedCount) return;
                const colorIndex = Math.sqrt(prime) * 4;
                const getHue = primeWaveColorPalettes[colorTheme];
                const rawHue = getHue(colorIndex, colorOffsetRef.current);
                const hue = rawHue < 0 ? (rawHue % 360) + 360 : rawHue % 360;
                let finalAlpha = alpha_ring;
                if (animationStyle === 'Breathing Journey' && prime === newestPrimeValue && newestPrimeValue > primes[1]) {
                    finalAlpha = alpha_ring * fadeInProgress;
                }
                ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${finalAlpha})`;
                ctx.beginPath();
                const R_i = R_base + radial_growth_per_prime * i;
                for (let j = 0; j < thetaSamples; j++) {
                    const angle = theta[j];
                    let r;
                    if (waveMotion === 'Rotate') {
                        r = R_i + (amplitude0 * amplitude) * Math.sin(prime * angle + activeWavePhaseRef.current);
                    } else if (waveMotion === 'Oscillate') {
                        const oscillationFactor = 1 + 0.2 * Math.sin(timestamp / 400 + i * 0.1);
                        r = R_i + ((amplitude0 * amplitude) * oscillationFactor) * Math.sin(prime * angle);
                    } else if (waveMotion === 'Ripple') {
                        const rippleFactor = 1 + 0.3 * Math.sin(4 * angle - timestamp / 800);
                        r = R_i + ((amplitude0 * amplitude) * rippleFactor) * Math.sin(prime * angle);
                    } else if (waveMotion === 'Chaos') {
                        const gap = (i < primes.length - 1) ? (primes[i+1] - primes[i]) : 2;
                        const chaosAmplitude = (amplitude0 * amplitude) * (1 + Math.log1p(gap) * 0.5);
                        
                        let chaoticPhaseShift;
                        if (prime > 3 && prime % 6 === 1) { // 6k+1, smoother chaos
                            chaoticPhaseShift = 2 * Math.sin(timestamp / 1000 + i * 0.2);
                        } else { // 6k-1 (and 2, 3), sharper chaos
                            chaoticPhaseShift = 2 * Math.sin(timestamp / 300 + i * 0.5) * Math.cos(prime * angle * 0.5);
                        }
                        
                        r = R_i + chaosAmplitude * Math.sin(prime * angle + chaoticPhaseShift);
                    }

                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);
                    if (j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
                i++;
            });
        } else {
            let i = 0;
            rings.forEach((points, prime) => {
              if (prime > currentAnimatedCount || points.length === 0) return;
              
              const colorIndex = Math.sqrt(prime) * 4;
              const getHue = primeWaveColorPalettes[colorTheme];
              const rawHue = getHue(colorIndex, colorOffsetRef.current);
              const hue = rawHue < 0 ? (rawHue % 360) + 360 : rawHue % 360;
              let finalAlpha = alpha_ring;
              if (animationStyle === 'Breathing Journey' && prime === newestPrimeValue && newestPrimeValue > primes[1]) {
                finalAlpha = alpha_ring * fadeInProgress;
              }
              ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${finalAlpha})`;
              ctx.beginPath();
              ctx.moveTo(points[0].x, points[0].y);
              for (let k = 1; k < points.length; k++) {
                ctx.lineTo(points[k].x, points[k].y);
              }
              ctx.closePath();
              ctx.stroke();
              i++;
            });
        }
      }
      ctx.restore();

      applyShader(ctx, shader, timestamp, { 
          echoes: echoesRef.current,
          maxCount,
          colorTheme,
          animationStyle,
          viewState,
          host: 'wave',
          lineWidth,
          isInterferenceEnabled
      });
      
      ctx.save();
      ctx.scale(dpr, dpr);
      const textX = (canvas.width / dpr) / 2;
      const textY = (canvas.height / dpr) / 2;
      if (showBreathingText && breathingCue) {
        ctx.font = 'normal 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.shadowColor = `rgba(0, 0, 0, ${0.9 * fadeOpacity})`;
        ctx.shadowBlur = 8;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * fadeOpacity})`;
        ctx.fillText(breathingCue, textX, textY);

        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
      }
      if (showJourneyPrime && animationStyle === 'Breathing Journey' && newestPrimeValue > -1) {
          ctx.font = '12px "Courier New", monospace';
          ctx.fillStyle = `rgba(255, 215, 0, ${0.5 * fadeInProgress * fadeOpacity})`;
          ctx.textAlign = 'center';
          ctx.shadowBlur = 5;
          ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
          ctx.fillText(`+ ${newestPrimeValue}`, textX, textY + 25);
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
      }
      ctx.restore();
      animationFrameId.current = requestAnimationFrame(draw);
    };
    animationFrameId.current = requestAnimationFrame(draw);
    return () => {
      animationRunning = false;
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [rings, primes, viewState, colorTheme, animationStyle, shader, maxCount, showBreathingText, showJourneyPrime, waveMotion, toneService, amplitude, lineWidth, isInterferenceEnabled]);

  return (
    <div
      ref={parentRef}
      className="w-full h-full relative cursor-grab touch-none select-none overflow-hidden"
    >
      <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full" />
    </div>
  );
};


// Inlined from components/PrimeWaveField.tsx
const verticalSpacingScale = 3;
const amplitude = 15;
const waveFrequencyScale = 0.01;
const alpha_wave = 0.6;
const primeWaveFieldColorPalettes = {
  Spectrum: (i, offset) => -i * 10 + offset,
  Ocean: (i, offset) => 200 + Math.sin((i + offset * 0.1) * 0.1) * 40,
  Sunset: (i, offset) => 30 + Math.sin((i + offset * 0.1) * 0.08) * 30,
  Forest: (i, offset) => 120 + Math.sin((i + offset * 0.1) * 0.1) * 30,
  Earth: (i, offset) => 80 + Math.sin((i + offset * 0.05) * 0.1) * 20,
  Autumn: (i, offset) => 30 + Math.sin((i + offset * 0.1) * 0.08) * 30,
  Cyberpunk: (i, offset) => 300 + Math.sin((i + offset * 0.1) * 0.06) * 60,
  Vaporwave: (i, offset) => 270 + Math.sin((i + offset * 0.1) * 0.1) * 40,
};

const PrimeWaveField = ({ maxCount, colorTheme, animationStyle, shader, showBreathingText, showJourneyPrime, waveMotion, onVizTapped, toneService, amplitude: amplitudeMultiplier, lineWidth, isInterferenceEnabled }) => {
  const canvasRef = useRef(null);
  const parentRef = useRef(null);
  const [viewState, setViewState] = useState({ x: 0, y: 0, zoom: 0.2 });
  const animationFrameId = useRef();
  const timeRef = useRef(0);
  const animationStateRef = useRef({ cycleStartTimestamp: 0, lastToneTriggerValue: 0 });
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const audioStreamRef = useRef(null);
  const phaseOffsetRef = useRef(0);
  const colorOffsetRef = useRef(0);
  const animatedPrimeCountRef = useRef(1);
  const echoesRef = useRef([]);
  const justInhaledRef = useRef(false);
  const animationDirectionRef = useRef('forward');
  const lastPlayedPrimeRef = useRef(-1);

  useUnifiedInteraction(canvasRef, viewState, setViewState, { onTapped: onVizTapped });
  
  const primes = useMemo(() => {
    const primeSieve = getPrimeSieve(maxCount);
    const primeList = [];
    for (let i = 2; i <= maxCount; i++) {
      if (primeSieve[i]) primeList.push(i);
    }
    return primeList;
  }, [maxCount]);

  const resetViewState = useCallback(() => {
    if (parentRef.current && primes.length > 1) {
        const { width, height } = parentRef.current.getBoundingClientRect();
        const yRange = (primes[primes.length - 1] - primes[0]) * verticalSpacingScale;
        const newZoom = Math.min(height / (yRange + (amplitude * amplitudeMultiplier) * 2), 0.2);
        setViewState({ x: width / 2, y: height / 2, zoom: newZoom });
    } else if (parentRef.current) {
        const { width, height } = parentRef.current.getBoundingClientRect();
        setViewState({ x: width / 2, y: height / 2, zoom: 0.2 });
    }
  }, [primes, amplitudeMultiplier]);
  
  useEffect(() => {
      resetViewState();
  }, [primes, resetViewState]);
  
  useEffect(() => {
    const handleResize = () => resetViewState();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [resetViewState]);

  useEffect(() => {
    animationStateRef.current.cycleStartTimestamp = timeRef.current;
    echoesRef.current = [];
    lastPlayedPrimeRef.current = -1;
    if (animationStyle === 'Breathing Journey') {
      animatedPrimeCountRef.current = 1;
    } else if (animationStyle === 'Linear Journey') {
      animatedPrimeCountRef.current = 0;
      if (animationDirectionRef.current !== 'forward') {
          animationDirectionRef.current = 'forward';
          if(toneService) toneService.clearAllTones();
      }
    } else {
      animatedPrimeCountRef.current = primes.length;
    }
  }, [animationStyle, primes, toneService]);

  useEffect(() => {
    const setupAudio = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStreamRef.current = stream;
        const context = new (window.AudioContext || window.webkitAudioContext)();
        audioContextRef.current = context;
        const source = context.createMediaStreamSource(stream);
        const analyser = context.createAnalyser();
        analyser.fftSize = 32;
        source.connect(analyser);
        analyserRef.current = analyser;
      } catch (err) {
        console.error('Microphone access denied:', err);
      }
    };
    const cleanupAudio = () => {
      audioStreamRef.current?.getTracks().forEach(track => track.stop());
      audioStreamRef.current = null;
      audioContextRef.current?.close();
      audioContextRef.current = null;
      analyserRef.current = null;
    };
    if (animationStyle === 'Sound Activated') setupAudio();
    return cleanupAudio;
  }, [animationStyle]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    let animationRunning = true;

    const draw = (timestamp) => {
      if (!animationRunning) return;
      timeRef.current = timestamp;
      if (animationStateRef.current.cycleStartTimestamp === 0) {
        animationStateRef.current.cycleStartTimestamp = timestamp;
      }
      let breathingCue = '';
      let fadeOpacity = 1.0;
      let fadeInProgress = 1.0;
      let newestPrimeValue = -1;
      let phaseSpeed = 0;
      let colorSpeed = 0;
      let isInhalePhase = false;
      
      switch (animationStyle) {
        case 'Slow':
          phaseSpeed = 0.02;
          colorSpeed = 0.5;
          break;
        case 'Pulse':
          {
            const speed = 1 + Math.sin(timeRef.current / 500) * 0.8;
            phaseSpeed = speed * 0.05;
            colorSpeed = speed;
          }
          break;
        case 'Linear Journey': {
            const journeyDurationSeconds = 90;
            const totalFrames = journeyDurationSeconds * 60;
            if (primes.length > 0) {
                const progressPerFrame = primes.length / totalFrames;
                if (animationDirectionRef.current === 'forward') {
                    animatedPrimeCountRef.current += progressPerFrame;
                    if (animatedPrimeCountRef.current >= primes.length) {
                        animatedPrimeCountRef.current = primes.length;
                        animationDirectionRef.current = 'backward';
                        if(toneService) toneService.clearAllTones();
                    }
                } else { // backward
                    animatedPrimeCountRef.current -= progressPerFrame;
                    if (animatedPrimeCountRef.current <= 0) {
                        animatedPrimeCountRef.current = 0;
                        animationDirectionRef.current = 'forward';
                        if(toneService) toneService.clearAllTones();
                    }
                }
            }
            phaseSpeed = 0.3;
            colorSpeed = 15;
            }
            break;
        case 'Breathing Journey':
        case 'Breathe (Resonant)':
          {
            const period = 10000;
            const phaseDuration = period / 2;
            const MAX_PHASE_SHIFT = Math.PI;
            const SHIFT_PER_PHASE = 150;
            const cycleTime = (timestamp - animationStateRef.current.cycleStartTimestamp) % period;
            const cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / period);
            const baseOffset = cycleNumber * SHIFT_PER_PHASE * 2;
            isInhalePhase = cycleTime < phaseDuration;
            const timeInPhase = cycleTime % phaseDuration;
            const phaseProgress = timeInPhase / phaseDuration;
            if (isInhalePhase) {
              phaseOffsetRef.current = easeInOutSine(phaseProgress) * MAX_PHASE_SHIFT;
              colorOffsetRef.current = baseOffset + easeInOutSine(phaseProgress) * SHIFT_PER_PHASE;
            } else {
              phaseOffsetRef.current = (1 - easeInOutSine(phaseProgress)) * MAX_PHASE_SHIFT;
              colorOffsetRef.current = baseOffset + SHIFT_PER_PHASE + easeInOutSine(phaseProgress) * SHIFT_PER_PHASE;
            }
            breathingCue = isInhalePhase ? 'Breathe In...' : 'Breathe Out...';
            fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
            if (animationStyle === 'Breathing Journey') {
              animatedPrimeCountRef.current = Math.min(primes.length, 1 + cycleNumber);
              if (animatedPrimeCountRef.current > 0) {
                  newestPrimeValue = primes[animatedPrimeCountRef.current - 1];
              }
              if (isInhalePhase) fadeInProgress = easeInOutSine(phaseProgress);
            }
          }
          break;
         case 'Breathe (4-7-8)':
          {
            const cycleDuration = 19000;
            const inhaleDuration = 4000, holdDuration = 7000, exhaleDuration = 8000;
            const cycleProgress = (timestamp - animationStateRef.current.cycleStartTimestamp) % cycleDuration;
            const MAX_PHASE_SHIFT = Math.PI;
            isInhalePhase = cycleProgress < inhaleDuration;
            if (isInhalePhase) {
              phaseOffsetRef.current = easeInOutSine(cycleProgress / inhaleDuration) * MAX_PHASE_SHIFT;
              breathingCue = 'Breathe In...';
              fadeOpacity = calculateFadeOpacity(cycleProgress, inhaleDuration);
            } else if (cycleProgress < inhaleDuration + holdDuration) {
              phaseOffsetRef.current = MAX_PHASE_SHIFT;
              breathingCue = 'Hold';
              const timeInPhase = cycleProgress - inhaleDuration;
              fadeOpacity = calculateFadeOpacity(timeInPhase, holdDuration);
            } else {
              phaseOffsetRef.current = (1 - easeInOutSine((cycleProgress - (inhaleDuration + holdDuration)) / exhaleDuration)) * MAX_PHASE_SHIFT;
              breathingCue = 'Breathe Out...';
              const timeInPhase = cycleProgress - (inhaleDuration + holdDuration);
              fadeOpacity = calculateFadeOpacity(timeInPhase, exhaleDuration);
            }
          }
          break;
        case 'Breathe (Box)':
          {
            const cycleDuration = 16000, phaseDuration = 4000;
            const cycleProgress = (timestamp - animationStateRef.current.cycleStartTimestamp) % cycleDuration;
            const MAX_PHASE_SHIFT = Math.PI;
            const timeInPhase = cycleProgress % phaseDuration;
            fadeOpacity = calculateFadeOpacity(timeInPhase, phaseDuration);
            isInhalePhase = cycleProgress < phaseDuration;
            if (isInhalePhase) {
              phaseOffsetRef.current = easeInOutSine(cycleProgress / phaseDuration) * MAX_PHASE_SHIFT;
              breathingCue = 'Breathe In...';
            } else if (cycleProgress < phaseDuration * 2) {
              phaseOffsetRef.current = MAX_PHASE_SHIFT;
              breathingCue = 'Hold';
            } else if (cycleProgress < phaseDuration * 3) {
              phaseOffsetRef.current = (1 - easeInOutSine((cycleProgress - phaseDuration * 2) / phaseDuration)) * MAX_PHASE_SHIFT;
              breathingCue = 'Breathe Out...';
            } else {
              phaseOffsetRef.current = 0;
              breathingCue = 'Hold';
            }
          }
          break;
        case 'Sound Activated':
          if (analyserRef.current) {
            const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
            analyserRef.current.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            phaseSpeed = (avg / 128) * 0.1;
            colorSpeed = (avg / 128) * 2;
          }
          break;
      }
      
      let isNewInhaleEvent = false;
      if (isInhalePhase && !justInhaledRef.current) {
          isNewInhaleEvent = true;
          justInhaledRef.current = true;
      } else if (!isInhalePhase) {
          justInhaledRef.current = false;
      }

      if (shader === 'Echo Spin' || shader === 'Echo Scale') {
        const ECHO_LIFETIME = 8000;
        echoesRef.current = echoesRef.current.filter(e => timestamp - e.creationTimestamp < ECHO_LIFETIME);
        if (isNewInhaleEvent) {
            echoesRef.current.push({
                creationTimestamp: timestamp,
                rotationSpeedMultiplier: 1 + (Math.random() - 0.5) * 0.4
            });
        }
      } else {
        echoesRef.current = [];
      }

      if (animationStyle !== 'Breathing Journey' && !animationStyle.startsWith('Breathe')) {
        phaseOffsetRef.current += phaseSpeed;
        colorOffsetRef.current += colorSpeed;
      }

      if (toneService) {
        let primeToPlay = null;
        if (animationStyle === 'Breathing Journey') {
            if (newestPrimeValue > -1 && newestPrimeValue !== lastPlayedPrimeRef.current) {
                primeToPlay = newestPrimeValue;
                lastPlayedPrimeRef.current = newestPrimeValue;
            }
        } else if (animationStyle.startsWith('Breathe')) {
            if (isNewInhaleEvent) {
                let cycleDuration = 10000;
                if (animationStyle === 'Breathe (4-7-8)') cycleDuration = 19000;
                if (animationStyle === 'Breathe (Box)') cycleDuration = 16000;
                const cycleNumber = Math.floor((timestamp - animationStateRef.current.cycleStartTimestamp) / cycleDuration);
                primeToPlay = primes[cycleNumber % primes.length];
            }
        } else if (animationStyle === 'Linear Journey') {
            const currentIndex = Math.floor(animatedPrimeCountRef.current);
            if(currentIndex > 0 && primes[currentIndex - 1] !== lastPlayedPrimeRef.current) {
                primeToPlay = primes[currentIndex - 1];
                lastPlayedPrimeRef.current = primeToPlay;
            }
        } else if (animationStyle === 'Sound Activated') {
            if (colorSpeed > 3 && timestamp - animationStateRef.current.lastToneTriggerValue > 500) {
                const primeIndex = Math.floor((colorSpeed / 5) * primes.length * 0.1);
                primeToPlay = primes[primeIndex];
                animationStateRef.current.lastToneTriggerValue = timestamp;
            }
        } else { // Slow, Pulse
            const TONE_INTERVAL = 360;
            const currentInterval = Math.floor(colorOffsetRef.current / TONE_INTERVAL);
            if (currentInterval !== animationStateRef.current.lastToneTriggerValue) {
                const primeIndex = currentInterval % primes.length;
                primeToPlay = primes[primeIndex];
                animationStateRef.current.lastToneTriggerValue = currentInterval;
            }
        }
        if(primeToPlay) toneService.play(primeToPlay);
      }
      
      const dpr = window.devicePixelRatio || 1;
      const rect = parentRef.current.getBoundingClientRect();
      if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }

      ctx.save();
      ctx.fillStyle = '#111827';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.scale(dpr, dpr);
      
      if (shader !== 'Prime Shader') {
        ctx.translate(viewState.x, viewState.y);
        ctx.scale(viewState.zoom, viewState.zoom);
        ctx.lineWidth = lineWidth / viewState.zoom;
        if (isInterferenceEnabled) {
            ctx.globalCompositeOperation = 'xor';
        }
        
        const viewPortLeft = -viewState.x / viewState.zoom;
        const viewPortRight = (rect.width - viewState.x) / viewState.zoom;
        const samples = Math.floor(viewPortRight - viewPortLeft);
        const step = (viewPortRight - viewPortLeft) / samples;
        
        const primeCountToRender = (animationStyle === 'Breathing Journey' || animationStyle === 'Linear Journey')
            ? Math.floor(animatedPrimeCountRef.current)
            : primes.length;

        if (primeCountToRender === 0) {
          ctx.restore();
          animationFrameId.current = requestAnimationFrame(draw);
          return;
        }
        
        const newestPrimeIndex = primeCountToRender - 1;
        
        const visiblePrimes = primes.slice(0, primeCountToRender);
        if (visiblePrimes.length === 0) {
            ctx.restore();
            animationFrameId.current = requestAnimationFrame(draw);
            return;
        }
        
        const centerPrimeValue = visiblePrimes[Math.floor(visiblePrimes.length / 2)];

        for (let i = 0; i < primeCountToRender; i++) {
          const p = primes[i];
          const y_base = (p - centerPrimeValue) * verticalSpacingScale;

          const colorIndex = Math.sqrt(p) * 4;
          const getHue = primeWaveFieldColorPalettes[colorTheme];
          const rawHue = getHue(colorIndex, colorOffsetRef.current);
          const hue = rawHue < 0 ? (rawHue % 360) + 360 : rawHue % 360;
          let finalAlpha = alpha_wave;
          if(animationStyle === 'Breathing Journey' && i === newestPrimeIndex && i > 0) {
              finalAlpha = alpha_wave * fadeInProgress;
          }
          ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${finalAlpha})`;
          
          let effectiveP = p;
          let baseAmplitude = amplitude * amplitudeMultiplier;
          if (waveMotion === 'Rotate') {
              effectiveP = p * (1 + 0.05 * Math.sin(timestamp / 500 + i * 0.5));
          } else if (waveMotion === 'Oscillate') {
              baseAmplitude = (amplitude * amplitudeMultiplier) * (1 + 0.3 * Math.sin(timestamp / 400 + i * 0.2));
          }

          ctx.beginPath();
          let firstPoint = true;
          for (let s = 0; s <= samples; s++) {
            const x = viewPortLeft + s * step;
            let y;

            if (waveMotion === 'Chaos') {
                const gap = (i < primeCountToRender - 1) ? (primes[i + 1] - primes[i]) : 2;
                const chaosAmplitude = (amplitude * amplitudeMultiplier) * (1 + Math.log1p(gap) * 0.7);

                let chaoticPhaseShift = 0;
                if (p > 3 && p % 6 === 1) { // Smoother chaos for 6k+1 primes
                    chaoticPhaseShift = Math.sin(timestamp / 1200 + i * 0.1);
                } else { // Sharper chaos for 6k-1 primes
                    chaoticPhaseShift = Math.sin(timestamp / 400 + p * 0.01) * Math.cos(x * 0.01);
                }
                
                y = y_base + chaosAmplitude * Math.sin(p * waveFrequencyScale * x + phaseOffsetRef.current + chaoticPhaseShift);
            } else {
                const currentAmplitude = waveMotion === 'Ripple'
                    ? (amplitude * amplitudeMultiplier) * (1 + 0.4 * Math.sin(x * 0.008 - timestamp / 600))
                    : baseAmplitude;
                y = y_base + currentAmplitude * Math.sin(effectiveP * waveFrequencyScale * x + phaseOffsetRef.current);
            }


            if (firstPoint) {
              ctx.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }
      }
      ctx.restore();

      applyShader(ctx, shader, timestamp, { 
          echoes: echoesRef.current,
          maxCount,
          colorTheme,
          animationStyle,
          viewState,
          host: 'wave-field',
          lineWidth,
          isInterferenceEnabled
      });

      ctx.save();
      ctx.scale(dpr, dpr);
      const textX = rect.width / 2;
      const textY = rect.height / 2;
      if (showBreathingText && breathingCue) {
        ctx.font = 'normal 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.shadowColor = `rgba(0, 0, 0, ${0.9 * fadeOpacity})`;
        ctx.shadowBlur = 8;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * fadeOpacity})`;
        ctx.fillText(breathingCue, textX, textY);

        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
      }
      if (showJourneyPrime && animationStyle === 'Breathing Journey' && newestPrimeValue > -1) {
          ctx.font = '12px "Courier New", monospace';
          ctx.fillStyle = `rgba(255, 215, 0, ${0.5 * fadeInProgress * fadeOpacity})`;
          ctx.textAlign = 'center';
          ctx.shadowBlur = 5;
          ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
          ctx.fillText(`+ ${newestPrimeValue}`, textX, textY + 25);
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
      }
      ctx.restore();
      animationFrameId.current = requestAnimationFrame(draw);
    };

    animationFrameId.current = requestAnimationFrame(draw);
    return () => {
      animationRunning = false;
      if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
    };
  }, [primes, viewState, colorTheme, animationStyle, shader, showBreathingText, showJourneyPrime, waveMotion, toneService, amplitudeMultiplier, lineWidth, isInterferenceEnabled]);


  return (
    <div
      ref={parentRef}
      className="w-full h-full relative cursor-grab touch-none select-none overflow-hidden"
    >
      <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full" />
    </div>
  );
};

// --- START INSTALL PROMPT ---
const InstallPrompt = ({ onClose }) => {
    const [os, setOs] = useState(null);

    useEffect(() => {
        const userAgent = window.navigator.userAgent;
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            setOs('iOS');
        } else if (/android/i.test(userAgent)) {
            setOs('Android');
        }
    }, []);

    const iosIcon = `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" class="w-6 h-6 inline-block mx-1">
            <path d="M12 20v-6M9 17l3-3 3 3"/>
            <path d="M18 8h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h2"/>
        </svg>
    `;

    const androidIcon = `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" class="w-5 h-5 inline-block">
            <path d="M12 5v14M12 5l-4 4M12 5l4 4"/>
        </svg>
    `;

    if (!os) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 animate-fade-in" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center text-gray-200" onClick={e => e.stopPropagation()}>
                <h3 className="text-xl font-bold text-yellow-300 mb-3">Get Fullscreen Experience</h3>
                <p className="mb-4">For the best experience, add this app to your home screen.</p>
                {os === 'iOS' && (
                    <div className="bg-gray-700 p-3 rounded-lg">
                        <p>1. Tap the <span dangerouslySetInnerHTML={{ __html: iosIcon }} /> Share button.</p>
                        <p>2. Scroll down and tap 'Add to Home Screen'.</p>
                    </div>
                )}
                {os === 'Android' && (
                    <div className="bg-gray-700 p-3 rounded-lg">
                        <p>1. Tap the three-dots menu icon.</p>
                        <p>2. Tap 'Add to Home Screen' or 'Install app'.</p>
                    </div>
                )}
                <button onClick={onClose} className="mt-5 bg-yellow-400 text-gray-900 font-bold py-2 px-4 rounded-lg hover:bg-yellow-300 transition-colors">
                    Got it!
                </button>
            </div>
        </div>
    );
};

// --- END INSTALL PROMPT ---

// Inlined from App.tsx
const App = () => {
  const [maxNumber, setMaxNumber] = useState(/Mobi|Android/i.test(navigator.userAgent) ? 600 : 1000);
  const [mode, setMode] = useState('wave');
  const [uiVisible, setUiVisible] = useState(true);
  const [colorTheme, setColorTheme] = useState('Spectrum');
  const [animationStyle, setAnimationStyle] = useState('Breathe (Resonant)');
  const [shader, setShader] = useState('None');
  const [showBreathingText, setShowBreathingText] = useState(true);
  const [showJourneyPrime, setShowJourneyPrime] = useState(false);
  const [waveMotion, setWaveMotion] = useState('Off');
  const [isToneEnabled, setIsToneEnabled] = useState(false);
  const [isInterferenceEnabled, setIsInterferenceEnabled] = useState(false);
  const [showInstallPrompt, setShowInstallPrompt] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(!!document.fullscreenElement);
  const [amplitude, setAmplitude] = useState(1.0);
  const [lineWidth, setLineWidth] = useState(1);
  const uiVisibilityTimer = useRef(null);
  const toneServiceRef = useRef(null);

  const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);
  const isFullscreenApiSupported = document.fullscreenEnabled !== undefined;
  
  const handleSetMode = (newMode) => {
    if (newMode === 'wave') {
      setMaxNumber(isMobile ? 600 : 1000);
    } else if (newMode === 'spiral') {
      setMaxNumber(3000);
    } else if (newMode === 'wave-field') {
      setMaxNumber(800);
    }
    setMode(newMode);
  };
  
  const handleSetAnimationStyle = async (newStyle) => {
    if (newStyle === 'Linear Journey') {
        setMaxNumber(20000);
    } else if (newStyle === 'Breathing Journey') {
        setWaveMotion('Rotate');
        setIsToneEnabled(true);
        setShowJourneyPrime(false);
    }

    if (newStyle === 'Sound Activated' && animationStyle !== 'Sound Activated') {
      try {
        await navigator.mediaDevices.getUserMedia({ audio: true });
        // We only request permission, the actual audio processing happens in the component
        setAnimationStyle(newStyle);
      } catch (err) {
        console.error('Microphone permission denied:', err);
        alert("Microphone access is required for the 'Sound Activated' animation. Please allow access in your browser settings to use this feature.");
      }
    } else {
      setAnimationStyle(newStyle);
    }
  };

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);

    const setters = {
        maxNumber: (val) => !isNaN(parseInt(val)) && setMaxNumber(parseInt(val, 10)),
        mode: handleSetMode,
        amplitude: (val) => !isNaN(parseFloat(val)) && setAmplitude(parseFloat(val)),
        lineWidth: (val) => !isNaN(parseInt(val)) && setLineWidth(parseInt(val, 10)),
        colorTheme: setColorTheme,
        animationStyle: handleSetAnimationStyle,
        shader: setShader,
        waveMotion: setWaveMotion,
        showBreathingText: (val) => setShowBreathingText(val === 'true'),
        isToneEnabled: (val) => setIsToneEnabled(val === 'true'),
        isInterferenceEnabled: (val) => setIsInterferenceEnabled(val === 'true'),
        showJourneyPrime: (val) => setShowJourneyPrime(val === 'true')
    };

    params.forEach((value, key) => {
        if (setters[key] && value) {
            setters[key](value);
        }
    });
  }, []); // Empty array ensures this runs only once on mount

  useEffect(() => {
    const root = document.documentElement;
    const setHeight = () => root.style.setProperty('--vh', `${window.innerHeight}px`);
    setHeight();
    window.addEventListener('resize', setHeight);
    return () => window.removeEventListener('resize', setHeight);
  }, []);

  useEffect(() => {
    const onFullscreenChange = () => {
        setIsFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener('fullscreenchange', onFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', onFullscreenChange);
  }, []);

    useEffect(() => {
        const resumeAudio = () => {
            if (toneServiceRef.current && toneServiceRef.current.audioContext && toneServiceRef.current.audioContext.state === 'suspended') {
                toneServiceRef.current.audioContext.resume();
            }
            window.removeEventListener('click', resumeAudio, { once: true });
            window.removeEventListener('touchstart', resumeAudio, { once: true });
        };
        window.addEventListener('click', resumeAudio, { once: true });
        window.addEventListener('touchstart', resumeAudio, { once: true });

        if (isToneEnabled && !toneServiceRef.current) {
            toneServiceRef.current = new ToneService();
        } else if (!isToneEnabled && toneServiceRef.current) {
            toneServiceRef.current.cleanup();
            toneServiceRef.current = null;
        }

        return () => {
            if (toneServiceRef.current) {
                toneServiceRef.current.cleanup();
                toneServiceRef.current = null;
            }
        };
    }, [isToneEnabled]);
  
  const handleToggleFullscreen = () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
  };

  const showUiAndResetTimer = useCallback(() => {
    setUiVisible(true);
    if (uiVisibilityTimer.current) {
      clearTimeout(uiVisibilityTimer.current);
    }
    uiVisibilityTimer.current = window.setTimeout(() => {
      setUiVisible(false);
    }, 6000);
  }, []);

  const handleVizTapped = useCallback(() => {
    setUiVisible(prevVisible => {
        const nextVisible = !prevVisible;
        if (uiVisibilityTimer.current) {
            clearTimeout(uiVisibilityTimer.current);
            uiVisibilityTimer.current = null;
        }
        if (nextVisible) {
            uiVisibilityTimer.current = window.setTimeout(() => {
                setUiVisible(false);
            }, 6000);
        }
        return nextVisible;
    });
  }, []);
  
  useEffect(() => {
    showUiAndResetTimer();
    window.addEventListener('mousemove', showUiAndResetTimer);
    window.addEventListener('mousedown', showUiAndResetTimer);
    window.addEventListener('touchstart', showUiAndResetTimer);
    window.addEventListener('wheel', showUiAndResetTimer, { passive: true });
    return () => {
      if (uiVisibilityTimer.current) {
        clearTimeout(uiVisibilityTimer.current);
      }
      window.removeEventListener('mousemove', showUiAndResetTimer);
      window.removeEventListener('mousedown', showUiAndResetTimer);
      window.removeEventListener('touchstart', showUiAndResetTimer);
      window.removeEventListener('wheel', showUiAndResetTimer);
    };
  }, [showUiAndResetTimer]);

  return (
    <main className="relative bg-gray-900 text-white overflow-hidden flex flex-col" style={{ height: 'var(--vh, 100vh)' }}>
      <div
        className={`absolute top-4 left-4 z-20 text-left p-2 md:p-4 transition-opacity duration-500 ${
          uiVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'
        }`}
      >
        <h1 className="text-2xl md:text-4xl font-bold text-yellow-300" style={{textShadow: '0 0 8px black, 0 0 8px black'}}>
          Prime Mind
        </h1>
        <p className="text-sm md:text-base text-gray-300 max-w-md mt-1" style={{textShadow: '0 0 6px black, 0 0 6px black'}}>
          A prime number visualization meditation tool.
        </p>
        <p className="text-xs md:text-sm text-gray-400 max-w-md mt-4" style={{textShadow: '0 0 6px black, 0 0 6px black'}}>
            Inspired by <a href="https://theprimescalarfield.com/" target="_blank" rel="noopener noreferrer" className="text-yellow-400 hover:text-yellow-300 underline">The Prime Scalar Field</a>. Watch the <a href="https://www.youtube.com/watch?v=Y9f-Gq42Pxg" target="_blank" rel="noopener noreferrer" className="text-yellow-400 hover:text-yellow-300 underline">video</a> to learn more.
        </p>
        <p className="text-xs text-gray-500 max-w-md mt-2" style={{textShadow: '0 0 6px black, 0 0 6px black'}}>
            Created by Chas Mastin, 2025, <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener noreferrer" className="text-gray-400 hover:text-gray-300 underline">MIT license</a>.
        </p>
      </div>

      <div
        className={`absolute top-4 right-4 z-20 flex items-center bg-gray-800 bg-opacity-70 backdrop-blur-sm rounded-lg shadow-lg p-1 transition-opacity duration-500 ${
          uiVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'
        }`}
      >
        <button onClick={() => handleSetMode('spiral')} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${mode === 'spiral' ? 'bg-yellow-400 text-gray-900' : 'text-gray-300 hover:bg-gray-700'}`}>Spiral</button>
        <button onClick={() => handleSetMode('wave')} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${mode === 'wave' ? 'bg-yellow-400 text-gray-900' : 'text-gray-300 hover:bg-gray-700'}`}>Wave</button>
        <button onClick={() => handleSetMode('wave-field')} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${mode === 'wave-field' ? 'bg-yellow-400 text-gray-900' : 'text-gray-300 hover:bg-gray-700'}`}>2D Field</button>
        {isMobile && !isStandalone && (
            <button onClick={() => setShowInstallPrompt(true)} className="ml-2 text-gray-300 hover:text-white" title="Install App">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            </button>
        )}
         {isFullscreenApiSupported && (
            <button onClick={handleToggleFullscreen} className="ml-2 text-gray-300 hover:text-white" title={isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}>
                {isFullscreen ? (
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
                ) : (
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                )}
            </button>
        )}
      </div>

      <div className="flex-grow w-full h-full z-0">
        {mode === 'spiral' ? (
          <PrimeSpiral count={maxNumber} animationStyle={animationStyle} colorTheme={colorTheme} shader={shader} showBreathingText={showBreathingText} showJourneyPrime={showJourneyPrime} waveMotion={waveMotion} onVizTapped={handleVizTapped} toneService={toneServiceRef.current} amplitude={amplitude} lineWidth={lineWidth} isInterferenceEnabled={isInterferenceEnabled} />
        ) : mode === 'wave' ? (
          <PrimeWave maxCount={maxNumber} colorTheme={colorTheme} animationStyle={animationStyle} shader={shader} showBreathingText={showBreathingText} showJourneyPrime={showJourneyPrime} waveMotion={waveMotion} onVizTapped={handleVizTapped} toneService={toneServiceRef.current} amplitude={amplitude} lineWidth={lineWidth} isInterferenceEnabled={isInterferenceEnabled} />
        ) : mode === 'wave-field' ? (
          <PrimeWaveField maxCount={maxNumber} colorTheme={colorTheme} animationStyle={animationStyle} shader={shader} showBreathingText={showBreathingText} showJourneyPrime={showJourneyPrime} waveMotion={waveMotion} onVizTapped={handleVizTapped} toneService={toneServiceRef.current} amplitude={amplitude} lineWidth={lineWidth} isInterferenceEnabled={isInterferenceEnabled} />
        ) : null}
      </div>
      <Controls
        value={maxNumber}
        setValue={setMaxNumber}
        amplitude={amplitude}
        setAmplitude={setAmplitude}
        lineWidth={lineWidth}
        setLineWidth={setLineWidth}
        mode={mode}
        colorTheme={colorTheme}
        setColorTheme={setColorTheme}
        animationStyle={animationStyle}
        setAnimationStyle={handleSetAnimationStyle}
        shader={shader}
        setShader={setShader}
        showBreathingText={showBreathingText}
        setShowBreathingText={setShowBreathingText}
        showJourneyPrime={showJourneyPrime}
        setShowJourneyPrime={setShowJourneyPrime}
        waveMotion={waveMotion}
        setWaveMotion={setWaveMotion}
        isToneEnabled={isToneEnabled}
        setIsToneEnabled={setIsToneEnabled}
        isInterferenceEnabled={isInterferenceEnabled}
        setIsInterferenceEnabled={setIsInterferenceEnabled}
        uiVisible={uiVisible}
      />
      {showInstallPrompt && <InstallPrompt onClose={() => setShowInstallPrompt(false)} />}
      <style>{`
          .animate-fade-in {
              animation: fadeIn 0.3s ease-out;
          }
          @keyframes fadeIn {
              from { opacity: 0; }
              to { opacity: 1; }
          }
      `}</style>
    </main>
  );
};


// Inlined from index.tsx
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// --- SCRIPT END ---
    </script>
</body>
</html>